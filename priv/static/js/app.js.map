{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./css/app.scss?242c","webpack:///./js/app.js","webpack:///./node_modules/nprogress/nprogress.js","webpack:///./node_modules/phoenix/priv/static/phoenix.mjs","webpack:///./node_modules/phoenix_html/priv/static/phoenix_html.js","webpack:///./node_modules/phoenix_live_view/priv/static/phoenix_live_view.esm.js"],"names":["csrfToken","document","querySelector","getAttribute","liveSocket","LiveSocket","Socket","params","_csrf_token","window","addEventListener","info","NProgress","start","done","connect","enableDebug"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,uC;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB;AACS;AACG;AACW;AAE5C,IAAIA,SAAS,GAAGC,QAAQ,CAACC,aAAa,CAAC,yBAAyB,CAAC,CAACC,YAAY,CAAC,SAAS,CAAC;AACzF,IAAIC,UAAU,GAAG,IAAIC,4DAAU,CAAC,OAAO,EAAEC,8CAAM,EAAE;EAACC,MAAM,EAAE;IAACC,WAAW,EAAER;EAAS;AAAC,CAAC,CAAC;;AAEpF;AACAS,MAAM,CAACC,gBAAgB,CAAC,wBAAwB,EAAE,UAAAC,IAAI;EAAA,OAAIC,gDAAS,CAACC,KAAK,EAAE;AAAA,EAAC;AAC5EJ,MAAM,CAACC,gBAAgB,CAAC,uBAAuB,EAAE,UAAAC,IAAI;EAAA,OAAIC,gDAAS,CAACE,IAAI,EAAE;AAAA,EAAC;;AAE1E;AACAV,UAAU,CAACW,OAAO,EAAE;;AAEpB;AACA;AACA;AACAN,MAAM,CAACL,UAAU,GAAGA,UAAU;AAE9BA,UAAU,CAACY,WAAW,EAAE,C;;;;;;;;;;;AClCxB;AACA;;AAEA,CAAC;;AAED,MAAM,IAA0C;AAChD,IAAI,oCAAO,OAAO;AAAA;AAAA;AAAA;AAAA,oGAAC;AACnB,GAAG,MAAM,EAIN;;AAEH,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uB;AACA;AACA;AACA,SAAS;AACT,6BAA6B;;AAE7B;AACA,yB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;AC1dD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4CAA4C,WAAW,GAAG,eAAe;AACzE;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8CAA8C,WAAW,IAAI,eAAe;AAC5E,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM,QAAQ,WAAW;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iCAAiC;AAClG;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU,GAAG,IAAI;AACrD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI,EAAE,OAAO,EAAE,uBAAuB;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAA4C,GAAG,yBAAyB;AACtG;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,WAAW,0BAA0B;AACrC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,iCAAiC,gBAAgB;AACjD;AACA;AACA,SAAS,gBAAgB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,kCAAkC;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,uCAAuC;AAC9D;AACA,GAAG;AACH;AACA,SAAS,uCAAuC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,YAAY;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,uBAAuB,SAAS,GAAG,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,gBAAgB;AAClG;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB,GAAG,IAAI;AACvC;AACA,cAAc,gBAAgB,KAAK,cAAc,EAAE,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAkD,OAAO;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,0BAA0B,MAAM,GAAG,MAAM,IAAI,SAAS,IAAI,IAAI;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAkD,iCAAiC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB,GAAG,MAAM,GAAG,MAAM,GAAG,6BAA6B;AACtG,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AAOE;AACF;;;;;;;;;;;;;ACxmCa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;AC7ED;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU,IAAI,0BAA0B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA,8CAA8C,YAAY;AAC1D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,KAAK,IAAI,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,qDAAqD;AACrD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,yBAAyB,KAAK,GAAG,MAAM;AACvC,GAAG;AACH;AACA,0DAA0D,KAAK,KAAK,SAAS;AAC7E,GAAG;AACH;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA,GAAG;AACH;AACA,cAAc,UAAU,GAAG,OAAO;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,8EAA8E,KAAK;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,GAAG;AACzE,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,gDAAgD,eAAe;AAC/D,GAAG;AACH;AACA,4DAA4D,cAAc,IAAI,IAAI;AAClF,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,4BAA4B,WAAW;AACvC,GAAG;AACH;AACA,2BAA2B,kBAAkB,GAAG,cAAc,IAAI,SAAS;AAC3E,GAAG;AACH;AACA;AACA;AACA,yBAAyB,cAAc,IAAI,IAAI,MAAM,cAAc;AACnE;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,iBAAiB;AAC1B,wBAAwB,aAAa,EAAE,IAAI,EAAE,aAAa;AAC1D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yDAAyD,MAAM,aAAa,MAAM,aAAa,MAAM;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iCAAiC,eAAe,IAAI,WAAW,OAAO,eAAe,IAAI,aAAa;AACtG;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,uDAAuD,cAAc;AACrE,GAAG;AACH,uCAAuC;AACvC;AACA,qBAAqB,qDAAqD;AAC1E;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH,sCAAsC;AACtC;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,oDAAoD;;AAE9E;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,mBAAmB;AAChH,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS,IAAI,qCAAqC;AACnH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,WAAW,iBAAiB;AAC5B,gCAAgC;AAChC;AACA;AACA,KAAK,IAAI;AACT;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS,oCAAoC;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS,+BAA+B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,mDAAmD;AAC5D;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS,0CAA0C;AACnD;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wEAAwE,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,GAAG,IAAI,GAAG,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,QAAQ,uBAAuB;;AAE/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,GAAG;AACH;AACA;AACA,4CAA4C;AAC5C,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,qBAAqB,KAAK;AAC1B,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH,0DAA0D,6BAA6B;AACvF;AACA;AACA,0CAA0C,kBAAkB;AAC5D,GAAG;AACH;AACA;AACA;AACA;AACA,SAAS,gEAAgE;AACzE,oBAAoB;AACpB;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH,0DAA0D,gBAAgB;AAC1E;AACA,GAAG;AACH,uDAAuD,gBAAgB;AACvE;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,2DAA2D,0BAA0B;AACrF;AACA,GAAG;AACH,8DAA8D,0BAA0B;AACxF;AACA,GAAG;AACH,4DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA,GAAG;AACH,wDAAwD,2BAA2B;AACnF;AACA,GAAG;AACH,sDAAsD,4BAA4B;AAClF;AACA,GAAG;AACH,sDAAsD,4BAA4B;AAClF;AACA,GAAG;AACH,0DAA0D,oBAAoB;AAC9E;AACA,GAAG;AACH,6DAA6D,OAAO;AACpE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+BAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6BAA6B;AACtC,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,kCAAkC,YAAY,IAAI,QAAQ,KAAK,QAAQ;AACvE;AACA;AACA,KAAK;AACL;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB,eAAe,SAAS;AAChF;AACA,KAAK;AACL,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA,iBAAiB,IAAI,GAAG,KAAK,IAAI,IAAI;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D,OAAO;AACP,KAAK;AACL,iCAAiC,YAAY,sBAAsB,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB,IAAI,qBAAqB,EAAE,GAAG;AAC1F;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iCAAiC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA,OAAO,8IAA8I,oBAAoB;AACzK,KAAK;AACL;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,UAAU,+BAA+B,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,uDAAuD,8BAA8B;AACrF;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,IAAI,QAAQ,KAAK,QAAQ,IAAI,IAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yCAAyC,cAAc;AACvD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wBAAwB;AACtE,KAAK;AACL,8CAA8C,wBAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,+BAA+B;AAC/B;AACA,iDAAiD,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE,KAAK;AACL,sEAAsE,KAAK;AAC3E,KAAK;AACL,+DAA+D,UAAU,sBAAsB,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,wCAAwC;AACzG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD,+DAA+D,QAAQ,KAAK,UAAU,IAAI,6BAA6B;AACvH;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qDAAqD,wBAAwB;AAC7E;AACA;AACA;AACA,SAAS;AACT;AACA,sDAAsD,8BAA8B;AACpF;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB,kBAAkB,WAAW;AAC7B,4DAA4D,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAuD,gBAAgB;AAC9G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,MAAM;AACvE;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB,EAAE,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB,QAAQ,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,6CAA6C;AAC3E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,gEAAgE,OAAO;AACvE,KAAK;AACL,eAAe,qCAAqC;AACpD;AACA,oBAAoB;AACpB,kEAAkE,OAAO;AACzE;AACA,KAAK;AACL,eAAe,+BAA+B;AAC9C;AACA;AACA,kEAAkE,OAAO;AACzE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM,4CAA4C,MAAM;AAC9F,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,2CAA2C;AAChH,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA,mEAAmE,6CAA6C;AAChH;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,yBAAyB;AACrG,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,sCAAsC,cAAc,qCAAqC,KAAK;AAC9F;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,mCAAmC;AACnC,6CAA6C,MAAM,IAAI,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF,iFAAiF,eAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,gBAAgB,SAAS,IAAI,KAAK,EAAE,KAAK;AACzC;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA,8CAA8C,6CAA6C;AAC3F;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,0CAA0C,8CAA8C;AACxF;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA,yDAAyD,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,qCAAqC;AAC5G,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;AACF","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// extracted by mini-css-extract-plugin","// We need to import the CSS so that webpack will load it.\r\n// The MiniCssExtractPlugin is used to separate it out into\r\n// its own CSS file.\r\nimport \"../css/app.scss\"\r\n\r\n// webpack automatically bundles all modules in your\r\n// entry points. Those entry points can be configured\r\n// in \"webpack.config.js\".\r\n//\r\n// Import deps with the dep name or local files with a relative path, for example:\r\n//\r\n//     import {Socket} from \"phoenix\"\r\n//     import socket from \"./socket\"\r\n//\r\nimport \"phoenix_html\"\r\nimport {Socket} from \"phoenix\"\r\nimport NProgress from \"nprogress\"\r\nimport {LiveSocket} from \"phoenix_live_view\"\r\n\r\nlet csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\")\r\nlet liveSocket = new LiveSocket(\"/live\", Socket, {params: {_csrf_token: csrfToken}})\r\n\r\n// Show progress bar on live navigation and form submits\r\nwindow.addEventListener(\"phx:page-loading-start\", info => NProgress.start())\r\nwindow.addEventListener(\"phx:page-loading-stop\", info => NProgress.done())\r\n\r\n// connect if there are any LiveViews on the page\r\nliveSocket.connect()\r\n\r\n// expose liveSocket on window for web console debug logs and latency simulation:\r\n// >> liveSocket.enableDebug()\r\n// >> liveSocket.enableLatencySim(1000)\r\nwindow.liveSocket = liveSocket\r\n\r\nliveSocket.enableDebug()","/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\r\n * @license MIT */\r\n\r\n;(function(root, factory) {\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(factory);\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = factory();\r\n  } else {\r\n    root.NProgress = factory();\r\n  }\r\n\r\n})(this, function() {\r\n  var NProgress = {};\r\n\r\n  NProgress.version = '0.2.0';\r\n\r\n  var Settings = NProgress.settings = {\r\n    minimum: 0.08,\r\n    easing: 'ease',\r\n    positionUsing: '',\r\n    speed: 200,\r\n    trickle: true,\r\n    trickleRate: 0.02,\r\n    trickleSpeed: 800,\r\n    showSpinner: true,\r\n    barSelector: '[role=\"bar\"]',\r\n    spinnerSelector: '[role=\"spinner\"]',\r\n    parent: 'body',\r\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\r\n  };\r\n\r\n  /**\r\n   * Updates configuration.\r\n   *\r\n   *     NProgress.configure({\r\n   *       minimum: 0.1\r\n   *     });\r\n   */\r\n  NProgress.configure = function(options) {\r\n    var key, value;\r\n    for (key in options) {\r\n      value = options[key];\r\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Last number.\r\n   */\r\n\r\n  NProgress.status = null;\r\n\r\n  /**\r\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\r\n   *\r\n   *     NProgress.set(0.4);\r\n   *     NProgress.set(1.0);\r\n   */\r\n\r\n  NProgress.set = function(n) {\r\n    var started = NProgress.isStarted();\r\n\r\n    n = clamp(n, Settings.minimum, 1);\r\n    NProgress.status = (n === 1 ? null : n);\r\n\r\n    var progress = NProgress.render(!started),\r\n        bar      = progress.querySelector(Settings.barSelector),\r\n        speed    = Settings.speed,\r\n        ease     = Settings.easing;\r\n\r\n    progress.offsetWidth; /* Repaint */\r\n\r\n    queue(function(next) {\r\n      // Set positionUsing if it hasn't already been set\r\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\r\n\r\n      // Add transition\r\n      css(bar, barPositionCSS(n, speed, ease));\r\n\r\n      if (n === 1) {\r\n        // Fade out\r\n        css(progress, { \r\n          transition: 'none', \r\n          opacity: 1 \r\n        });\r\n        progress.offsetWidth; /* Repaint */\r\n\r\n        setTimeout(function() {\r\n          css(progress, { \r\n            transition: 'all ' + speed + 'ms linear', \r\n            opacity: 0 \r\n          });\r\n          setTimeout(function() {\r\n            NProgress.remove();\r\n            next();\r\n          }, speed);\r\n        }, speed);\r\n      } else {\r\n        setTimeout(next, speed);\r\n      }\r\n    });\r\n\r\n    return this;\r\n  };\r\n\r\n  NProgress.isStarted = function() {\r\n    return typeof NProgress.status === 'number';\r\n  };\r\n\r\n  /**\r\n   * Shows the progress bar.\r\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\r\n   *\r\n   *     NProgress.start();\r\n   *\r\n   */\r\n  NProgress.start = function() {\r\n    if (!NProgress.status) NProgress.set(0);\r\n\r\n    var work = function() {\r\n      setTimeout(function() {\r\n        if (!NProgress.status) return;\r\n        NProgress.trickle();\r\n        work();\r\n      }, Settings.trickleSpeed);\r\n    };\r\n\r\n    if (Settings.trickle) work();\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Hides the progress bar.\r\n   * This is the *sort of* the same as setting the status to 100%, with the\r\n   * difference being `done()` makes some placebo effect of some realistic motion.\r\n   *\r\n   *     NProgress.done();\r\n   *\r\n   * If `true` is passed, it will show the progress bar even if its hidden.\r\n   *\r\n   *     NProgress.done(true);\r\n   */\r\n\r\n  NProgress.done = function(force) {\r\n    if (!force && !NProgress.status) return this;\r\n\r\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\r\n  };\r\n\r\n  /**\r\n   * Increments by a random amount.\r\n   */\r\n\r\n  NProgress.inc = function(amount) {\r\n    var n = NProgress.status;\r\n\r\n    if (!n) {\r\n      return NProgress.start();\r\n    } else {\r\n      if (typeof amount !== 'number') {\r\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\r\n      }\r\n\r\n      n = clamp(n + amount, 0, 0.994);\r\n      return NProgress.set(n);\r\n    }\r\n  };\r\n\r\n  NProgress.trickle = function() {\r\n    return NProgress.inc(Math.random() * Settings.trickleRate);\r\n  };\r\n\r\n  /**\r\n   * Waits for all supplied jQuery promises and\r\n   * increases the progress as the promises resolve.\r\n   *\r\n   * @param $promise jQUery Promise\r\n   */\r\n  (function() {\r\n    var initial = 0, current = 0;\r\n\r\n    NProgress.promise = function($promise) {\r\n      if (!$promise || $promise.state() === \"resolved\") {\r\n        return this;\r\n      }\r\n\r\n      if (current === 0) {\r\n        NProgress.start();\r\n      }\r\n\r\n      initial++;\r\n      current++;\r\n\r\n      $promise.always(function() {\r\n        current--;\r\n        if (current === 0) {\r\n            initial = 0;\r\n            NProgress.done();\r\n        } else {\r\n            NProgress.set((initial - current) / initial);\r\n        }\r\n      });\r\n\r\n      return this;\r\n    };\r\n\r\n  })();\r\n\r\n  /**\r\n   * (Internal) renders the progress bar markup based on the `template`\r\n   * setting.\r\n   */\r\n\r\n  NProgress.render = function(fromStart) {\r\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\r\n\r\n    addClass(document.documentElement, 'nprogress-busy');\r\n    \r\n    var progress = document.createElement('div');\r\n    progress.id = 'nprogress';\r\n    progress.innerHTML = Settings.template;\r\n\r\n    var bar      = progress.querySelector(Settings.barSelector),\r\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\r\n        parent   = document.querySelector(Settings.parent),\r\n        spinner;\r\n    \r\n    css(bar, {\r\n      transition: 'all 0 linear',\r\n      transform: 'translate3d(' + perc + '%,0,0)'\r\n    });\r\n\r\n    if (!Settings.showSpinner) {\r\n      spinner = progress.querySelector(Settings.spinnerSelector);\r\n      spinner && removeElement(spinner);\r\n    }\r\n\r\n    if (parent != document.body) {\r\n      addClass(parent, 'nprogress-custom-parent');\r\n    }\r\n\r\n    parent.appendChild(progress);\r\n    return progress;\r\n  };\r\n\r\n  /**\r\n   * Removes the element. Opposite of render().\r\n   */\r\n\r\n  NProgress.remove = function() {\r\n    removeClass(document.documentElement, 'nprogress-busy');\r\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\r\n    var progress = document.getElementById('nprogress');\r\n    progress && removeElement(progress);\r\n  };\r\n\r\n  /**\r\n   * Checks if the progress bar is rendered.\r\n   */\r\n\r\n  NProgress.isRendered = function() {\r\n    return !!document.getElementById('nprogress');\r\n  };\r\n\r\n  /**\r\n   * Determine which positioning CSS rule to use.\r\n   */\r\n\r\n  NProgress.getPositioningCSS = function() {\r\n    // Sniff on document.body.style\r\n    var bodyStyle = document.body.style;\r\n\r\n    // Sniff prefixes\r\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\r\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\r\n                       ('msTransform' in bodyStyle) ? 'ms' :\r\n                       ('OTransform' in bodyStyle) ? 'O' : '';\r\n\r\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\r\n      // Modern browsers with 3D support, e.g. Webkit, IE10\r\n      return 'translate3d';\r\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\r\n      // Browsers without 3D support, e.g. IE9\r\n      return 'translate';\r\n    } else {\r\n      // Browsers without translate() support, e.g. IE7-8\r\n      return 'margin';\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Helpers\r\n   */\r\n\r\n  function clamp(n, min, max) {\r\n    if (n < min) return min;\r\n    if (n > max) return max;\r\n    return n;\r\n  }\r\n\r\n  /**\r\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\r\n   * percentage (`-100%..0%`).\r\n   */\r\n\r\n  function toBarPerc(n) {\r\n    return (-1 + n) * 100;\r\n  }\r\n\r\n\r\n  /**\r\n   * (Internal) returns the correct CSS for changing the bar's\r\n   * position given an n percentage, and speed and ease from Settings\r\n   */\r\n\r\n  function barPositionCSS(n, speed, ease) {\r\n    var barCSS;\r\n\r\n    if (Settings.positionUsing === 'translate3d') {\r\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\r\n    } else if (Settings.positionUsing === 'translate') {\r\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\r\n    } else {\r\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\r\n    }\r\n\r\n    barCSS.transition = 'all '+speed+'ms '+ease;\r\n\r\n    return barCSS;\r\n  }\r\n\r\n  /**\r\n   * (Internal) Queues a function to be executed.\r\n   */\r\n\r\n  var queue = (function() {\r\n    var pending = [];\r\n    \r\n    function next() {\r\n      var fn = pending.shift();\r\n      if (fn) {\r\n        fn(next);\r\n      }\r\n    }\r\n\r\n    return function(fn) {\r\n      pending.push(fn);\r\n      if (pending.length == 1) next();\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * (Internal) Applies css properties to an element, similar to the jQuery \r\n   * css method.\r\n   *\r\n   * While this helper does assist with vendor prefixed property names, it \r\n   * does not perform any manipulation of values prior to setting styles.\r\n   */\r\n\r\n  var css = (function() {\r\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\r\n        cssProps    = {};\r\n\r\n    function camelCase(string) {\r\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\r\n        return letter.toUpperCase();\r\n      });\r\n    }\r\n\r\n    function getVendorProp(name) {\r\n      var style = document.body.style;\r\n      if (name in style) return name;\r\n\r\n      var i = cssPrefixes.length,\r\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\r\n          vendorName;\r\n      while (i--) {\r\n        vendorName = cssPrefixes[i] + capName;\r\n        if (vendorName in style) return vendorName;\r\n      }\r\n\r\n      return name;\r\n    }\r\n\r\n    function getStyleProp(name) {\r\n      name = camelCase(name);\r\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\r\n    }\r\n\r\n    function applyCss(element, prop, value) {\r\n      prop = getStyleProp(prop);\r\n      element.style[prop] = value;\r\n    }\r\n\r\n    return function(element, properties) {\r\n      var args = arguments,\r\n          prop, \r\n          value;\r\n\r\n      if (args.length == 2) {\r\n        for (prop in properties) {\r\n          value = properties[prop];\r\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\r\n        }\r\n      } else {\r\n        applyCss(element, args[1], args[2]);\r\n      }\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\r\n   */\r\n\r\n  function hasClass(element, name) {\r\n    var list = typeof element == 'string' ? element : classList(element);\r\n    return list.indexOf(' ' + name + ' ') >= 0;\r\n  }\r\n\r\n  /**\r\n   * (Internal) Adds a class to an element.\r\n   */\r\n\r\n  function addClass(element, name) {\r\n    var oldList = classList(element),\r\n        newList = oldList + name;\r\n\r\n    if (hasClass(oldList, name)) return; \r\n\r\n    // Trim the opening space.\r\n    element.className = newList.substring(1);\r\n  }\r\n\r\n  /**\r\n   * (Internal) Removes a class from an element.\r\n   */\r\n\r\n  function removeClass(element, name) {\r\n    var oldList = classList(element),\r\n        newList;\r\n\r\n    if (!hasClass(element, name)) return;\r\n\r\n    // Replace the class name.\r\n    newList = oldList.replace(' ' + name + ' ', ' ');\r\n\r\n    // Trim the opening and closing spaces.\r\n    element.className = newList.substring(1, newList.length - 1);\r\n  }\r\n\r\n  /**\r\n   * (Internal) Gets a space separated list of the class names on the element. \r\n   * The list is wrapped with a single space on each end to facilitate finding \r\n   * matches within the list.\r\n   */\r\n\r\n  function classList(element) {\r\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\r\n  }\r\n\r\n  /**\r\n   * (Internal) Removes an element from the DOM.\r\n   */\r\n\r\n  function removeElement(element) {\r\n    element && element.parentNode && element.parentNode.removeChild(element);\r\n  }\r\n\r\n  return NProgress;\r\n});\r\n\r\n","// js/phoenix/utils.js\r\nvar closure = (value) => {\r\n  if (typeof value === \"function\") {\r\n    return value;\r\n  } else {\r\n    let closure2 = function() {\r\n      return value;\r\n    };\r\n    return closure2;\r\n  }\r\n};\r\n\r\n// js/phoenix/constants.js\r\nvar globalSelf = typeof self !== \"undefined\" ? self : null;\r\nvar phxWindow = typeof window !== \"undefined\" ? window : null;\r\nvar global = globalSelf || phxWindow || global;\r\nvar DEFAULT_VSN = \"2.0.0\";\r\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\r\nvar DEFAULT_TIMEOUT = 1e4;\r\nvar WS_CLOSE_NORMAL = 1e3;\r\nvar CHANNEL_STATES = {\r\n  closed: \"closed\",\r\n  errored: \"errored\",\r\n  joined: \"joined\",\r\n  joining: \"joining\",\r\n  leaving: \"leaving\"\r\n};\r\nvar CHANNEL_EVENTS = {\r\n  close: \"phx_close\",\r\n  error: \"phx_error\",\r\n  join: \"phx_join\",\r\n  reply: \"phx_reply\",\r\n  leave: \"phx_leave\"\r\n};\r\nvar TRANSPORTS = {\r\n  longpoll: \"longpoll\",\r\n  websocket: \"websocket\"\r\n};\r\nvar XHR_STATES = {\r\n  complete: 4\r\n};\r\n\r\n// js/phoenix/push.js\r\nvar Push = class {\r\n  constructor(channel, event, payload, timeout) {\r\n    this.channel = channel;\r\n    this.event = event;\r\n    this.payload = payload || function() {\r\n      return {};\r\n    };\r\n    this.receivedResp = null;\r\n    this.timeout = timeout;\r\n    this.timeoutTimer = null;\r\n    this.recHooks = [];\r\n    this.sent = false;\r\n  }\r\n  resend(timeout) {\r\n    this.timeout = timeout;\r\n    this.reset();\r\n    this.send();\r\n  }\r\n  send() {\r\n    if (this.hasReceived(\"timeout\")) {\r\n      return;\r\n    }\r\n    this.startTimeout();\r\n    this.sent = true;\r\n    this.channel.socket.push({\r\n      topic: this.channel.topic,\r\n      event: this.event,\r\n      payload: this.payload(),\r\n      ref: this.ref,\r\n      join_ref: this.channel.joinRef()\r\n    });\r\n  }\r\n  receive(status, callback) {\r\n    if (this.hasReceived(status)) {\r\n      callback(this.receivedResp.response);\r\n    }\r\n    this.recHooks.push({ status, callback });\r\n    return this;\r\n  }\r\n  reset() {\r\n    this.cancelRefEvent();\r\n    this.ref = null;\r\n    this.refEvent = null;\r\n    this.receivedResp = null;\r\n    this.sent = false;\r\n  }\r\n  matchReceive({ status, response, _ref }) {\r\n    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\r\n  }\r\n  cancelRefEvent() {\r\n    if (!this.refEvent) {\r\n      return;\r\n    }\r\n    this.channel.off(this.refEvent);\r\n  }\r\n  cancelTimeout() {\r\n    clearTimeout(this.timeoutTimer);\r\n    this.timeoutTimer = null;\r\n  }\r\n  startTimeout() {\r\n    if (this.timeoutTimer) {\r\n      this.cancelTimeout();\r\n    }\r\n    this.ref = this.channel.socket.makeRef();\r\n    this.refEvent = this.channel.replyEventName(this.ref);\r\n    this.channel.on(this.refEvent, (payload) => {\r\n      this.cancelRefEvent();\r\n      this.cancelTimeout();\r\n      this.receivedResp = payload;\r\n      this.matchReceive(payload);\r\n    });\r\n    this.timeoutTimer = setTimeout(() => {\r\n      this.trigger(\"timeout\", {});\r\n    }, this.timeout);\r\n  }\r\n  hasReceived(status) {\r\n    return this.receivedResp && this.receivedResp.status === status;\r\n  }\r\n  trigger(status, response) {\r\n    this.channel.trigger(this.refEvent, { status, response });\r\n  }\r\n};\r\n\r\n// js/phoenix/timer.js\r\nvar Timer = class {\r\n  constructor(callback, timerCalc) {\r\n    this.callback = callback;\r\n    this.timerCalc = timerCalc;\r\n    this.timer = null;\r\n    this.tries = 0;\r\n  }\r\n  reset() {\r\n    this.tries = 0;\r\n    clearTimeout(this.timer);\r\n  }\r\n  scheduleTimeout() {\r\n    clearTimeout(this.timer);\r\n    this.timer = setTimeout(() => {\r\n      this.tries = this.tries + 1;\r\n      this.callback();\r\n    }, this.timerCalc(this.tries + 1));\r\n  }\r\n};\r\n\r\n// js/phoenix/channel.js\r\nvar Channel = class {\r\n  constructor(topic, params, socket) {\r\n    this.state = CHANNEL_STATES.closed;\r\n    this.topic = topic;\r\n    this.params = closure(params || {});\r\n    this.socket = socket;\r\n    this.bindings = [];\r\n    this.bindingRef = 0;\r\n    this.timeout = this.socket.timeout;\r\n    this.joinedOnce = false;\r\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\r\n    this.pushBuffer = [];\r\n    this.stateChangeRefs = [];\r\n    this.rejoinTimer = new Timer(() => {\r\n      if (this.socket.isConnected()) {\r\n        this.rejoin();\r\n      }\r\n    }, this.socket.rejoinAfterMs);\r\n    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\r\n    this.stateChangeRefs.push(this.socket.onOpen(() => {\r\n      this.rejoinTimer.reset();\r\n      if (this.isErrored()) {\r\n        this.rejoin();\r\n      }\r\n    }));\r\n    this.joinPush.receive(\"ok\", () => {\r\n      this.state = CHANNEL_STATES.joined;\r\n      this.rejoinTimer.reset();\r\n      this.pushBuffer.forEach((pushEvent) => pushEvent.send());\r\n      this.pushBuffer = [];\r\n    });\r\n    this.joinPush.receive(\"error\", () => {\r\n      this.state = CHANNEL_STATES.errored;\r\n      if (this.socket.isConnected()) {\r\n        this.rejoinTimer.scheduleTimeout();\r\n      }\r\n    });\r\n    this.onClose(() => {\r\n      this.rejoinTimer.reset();\r\n      if (this.socket.hasLogger())\r\n        this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\r\n      this.state = CHANNEL_STATES.closed;\r\n      this.socket.remove(this);\r\n    });\r\n    this.onError((reason) => {\r\n      if (this.socket.hasLogger())\r\n        this.socket.log(\"channel\", `error ${this.topic}`, reason);\r\n      if (this.isJoining()) {\r\n        this.joinPush.reset();\r\n      }\r\n      this.state = CHANNEL_STATES.errored;\r\n      if (this.socket.isConnected()) {\r\n        this.rejoinTimer.scheduleTimeout();\r\n      }\r\n    });\r\n    this.joinPush.receive(\"timeout\", () => {\r\n      if (this.socket.hasLogger())\r\n        this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\r\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\r\n      leavePush.send();\r\n      this.state = CHANNEL_STATES.errored;\r\n      this.joinPush.reset();\r\n      if (this.socket.isConnected()) {\r\n        this.rejoinTimer.scheduleTimeout();\r\n      }\r\n    });\r\n    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\r\n      this.trigger(this.replyEventName(ref), payload);\r\n    });\r\n  }\r\n  join(timeout = this.timeout) {\r\n    if (this.joinedOnce) {\r\n      throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\r\n    } else {\r\n      this.timeout = timeout;\r\n      this.joinedOnce = true;\r\n      this.rejoin();\r\n      return this.joinPush;\r\n    }\r\n  }\r\n  onClose(callback) {\r\n    this.on(CHANNEL_EVENTS.close, callback);\r\n  }\r\n  onError(callback) {\r\n    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\r\n  }\r\n  on(event, callback) {\r\n    let ref = this.bindingRef++;\r\n    this.bindings.push({ event, ref, callback });\r\n    return ref;\r\n  }\r\n  off(event, ref) {\r\n    this.bindings = this.bindings.filter((bind) => {\r\n      return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\r\n    });\r\n  }\r\n  canPush() {\r\n    return this.socket.isConnected() && this.isJoined();\r\n  }\r\n  push(event, payload, timeout = this.timeout) {\r\n    payload = payload || {};\r\n    if (!this.joinedOnce) {\r\n      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\r\n    }\r\n    let pushEvent = new Push(this, event, function() {\r\n      return payload;\r\n    }, timeout);\r\n    if (this.canPush()) {\r\n      pushEvent.send();\r\n    } else {\r\n      pushEvent.startTimeout();\r\n      this.pushBuffer.push(pushEvent);\r\n    }\r\n    return pushEvent;\r\n  }\r\n  leave(timeout = this.timeout) {\r\n    this.rejoinTimer.reset();\r\n    this.joinPush.cancelTimeout();\r\n    this.state = CHANNEL_STATES.leaving;\r\n    let onClose = () => {\r\n      if (this.socket.hasLogger())\r\n        this.socket.log(\"channel\", `leave ${this.topic}`);\r\n      this.trigger(CHANNEL_EVENTS.close, \"leave\");\r\n    };\r\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\r\n    leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\r\n    leavePush.send();\r\n    if (!this.canPush()) {\r\n      leavePush.trigger(\"ok\", {});\r\n    }\r\n    return leavePush;\r\n  }\r\n  onMessage(_event, payload, _ref) {\r\n    return payload;\r\n  }\r\n  isMember(topic, event, payload, joinRef) {\r\n    if (this.topic !== topic) {\r\n      return false;\r\n    }\r\n    if (joinRef && joinRef !== this.joinRef()) {\r\n      if (this.socket.hasLogger())\r\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic, event, payload, joinRef });\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n  joinRef() {\r\n    return this.joinPush.ref;\r\n  }\r\n  rejoin(timeout = this.timeout) {\r\n    if (this.isLeaving()) {\r\n      return;\r\n    }\r\n    this.socket.leaveOpenTopic(this.topic);\r\n    this.state = CHANNEL_STATES.joining;\r\n    this.joinPush.resend(timeout);\r\n  }\r\n  trigger(event, payload, ref, joinRef) {\r\n    let handledPayload = this.onMessage(event, payload, ref, joinRef);\r\n    if (payload && !handledPayload) {\r\n      throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\r\n    }\r\n    let eventBindings = this.bindings.filter((bind) => bind.event === event);\r\n    for (let i = 0; i < eventBindings.length; i++) {\r\n      let bind = eventBindings[i];\r\n      bind.callback(handledPayload, ref, joinRef || this.joinRef());\r\n    }\r\n  }\r\n  replyEventName(ref) {\r\n    return `chan_reply_${ref}`;\r\n  }\r\n  isClosed() {\r\n    return this.state === CHANNEL_STATES.closed;\r\n  }\r\n  isErrored() {\r\n    return this.state === CHANNEL_STATES.errored;\r\n  }\r\n  isJoined() {\r\n    return this.state === CHANNEL_STATES.joined;\r\n  }\r\n  isJoining() {\r\n    return this.state === CHANNEL_STATES.joining;\r\n  }\r\n  isLeaving() {\r\n    return this.state === CHANNEL_STATES.leaving;\r\n  }\r\n};\r\n\r\n// js/phoenix/ajax.js\r\nvar Ajax = class {\r\n  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\r\n    if (global.XDomainRequest) {\r\n      let req = new global.XDomainRequest();\r\n      return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\r\n    } else {\r\n      let req = new global.XMLHttpRequest();\r\n      return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\r\n    }\r\n  }\r\n  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\r\n    req.timeout = timeout;\r\n    req.open(method, endPoint);\r\n    req.onload = () => {\r\n      let response = this.parseJSON(req.responseText);\r\n      callback && callback(response);\r\n    };\r\n    if (ontimeout) {\r\n      req.ontimeout = ontimeout;\r\n    }\r\n    req.onprogress = () => {\r\n    };\r\n    req.send(body);\r\n    return req;\r\n  }\r\n  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\r\n    req.open(method, endPoint, true);\r\n    req.timeout = timeout;\r\n    req.setRequestHeader(\"Content-Type\", accept);\r\n    req.onerror = () => callback && callback(null);\r\n    req.onreadystatechange = () => {\r\n      if (req.readyState === XHR_STATES.complete && callback) {\r\n        let response = this.parseJSON(req.responseText);\r\n        callback(response);\r\n      }\r\n    };\r\n    if (ontimeout) {\r\n      req.ontimeout = ontimeout;\r\n    }\r\n    req.send(body);\r\n    return req;\r\n  }\r\n  static parseJSON(resp) {\r\n    if (!resp || resp === \"\") {\r\n      return null;\r\n    }\r\n    try {\r\n      return JSON.parse(resp);\r\n    } catch (e) {\r\n      console && console.log(\"failed to parse JSON response\", resp);\r\n      return null;\r\n    }\r\n  }\r\n  static serialize(obj, parentKey) {\r\n    let queryStr = [];\r\n    for (var key in obj) {\r\n      if (!Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        continue;\r\n      }\r\n      let paramKey = parentKey ? `${parentKey}[${key}]` : key;\r\n      let paramVal = obj[key];\r\n      if (typeof paramVal === \"object\") {\r\n        queryStr.push(this.serialize(paramVal, paramKey));\r\n      } else {\r\n        queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\r\n      }\r\n    }\r\n    return queryStr.join(\"&\");\r\n  }\r\n  static appendParams(url, params) {\r\n    if (Object.keys(params).length === 0) {\r\n      return url;\r\n    }\r\n    let prefix = url.match(/\\?/) ? \"&\" : \"?\";\r\n    return `${url}${prefix}${this.serialize(params)}`;\r\n  }\r\n};\r\n\r\n// js/phoenix/longpoll.js\r\nvar LongPoll = class {\r\n  constructor(endPoint) {\r\n    this.endPoint = null;\r\n    this.token = null;\r\n    this.skipHeartbeat = true;\r\n    this.reqs = /* @__PURE__ */ new Set();\r\n    this.onopen = function() {\r\n    };\r\n    this.onerror = function() {\r\n    };\r\n    this.onmessage = function() {\r\n    };\r\n    this.onclose = function() {\r\n    };\r\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\r\n    this.readyState = SOCKET_STATES.connecting;\r\n    this.poll();\r\n  }\r\n  normalizeEndpoint(endPoint) {\r\n    return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\r\n  }\r\n  endpointURL() {\r\n    return Ajax.appendParams(this.pollEndpoint, { token: this.token });\r\n  }\r\n  closeAndRetry(code, reason, wasClean) {\r\n    this.close(code, reason, wasClean);\r\n    this.readyState = SOCKET_STATES.connecting;\r\n  }\r\n  ontimeout() {\r\n    this.onerror(\"timeout\");\r\n    this.closeAndRetry(1005, \"timeout\", false);\r\n  }\r\n  isActive() {\r\n    return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;\r\n  }\r\n  poll() {\r\n    this.ajax(\"GET\", null, () => this.ontimeout(), (resp) => {\r\n      if (resp) {\r\n        var { status, token, messages } = resp;\r\n        this.token = token;\r\n      } else {\r\n        status = 0;\r\n      }\r\n      switch (status) {\r\n        case 200:\r\n          messages.forEach((msg) => {\r\n            setTimeout(() => this.onmessage({ data: msg }), 0);\r\n          });\r\n          this.poll();\r\n          break;\r\n        case 204:\r\n          this.poll();\r\n          break;\r\n        case 410:\r\n          this.readyState = SOCKET_STATES.open;\r\n          this.onopen({});\r\n          this.poll();\r\n          break;\r\n        case 403:\r\n          this.onerror(403);\r\n          this.close(1008, \"forbidden\", false);\r\n          break;\r\n        case 0:\r\n        case 500:\r\n          this.onerror(500);\r\n          this.closeAndRetry(1011, \"internal server error\", 500);\r\n          break;\r\n        default:\r\n          throw new Error(`unhandled poll status ${status}`);\r\n      }\r\n    });\r\n  }\r\n  send(body) {\r\n    this.ajax(\"POST\", body, () => this.onerror(\"timeout\"), (resp) => {\r\n      if (!resp || resp.status !== 200) {\r\n        this.onerror(resp && resp.status);\r\n        this.closeAndRetry(1011, \"internal server error\", false);\r\n      }\r\n    });\r\n  }\r\n  close(code, reason, wasClean) {\r\n    for (let req of this.reqs) {\r\n      req.abort();\r\n    }\r\n    this.readyState = SOCKET_STATES.closed;\r\n    let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });\r\n    if (typeof CloseEvent !== \"undefined\") {\r\n      this.onclose(new CloseEvent(\"close\", opts));\r\n    } else {\r\n      this.onclose(opts);\r\n    }\r\n  }\r\n  ajax(method, body, onCallerTimeout, callback) {\r\n    let req;\r\n    let ontimeout = () => {\r\n      this.reqs.delete(req);\r\n      onCallerTimeout();\r\n    };\r\n    req = Ajax.request(method, this.endpointURL(), \"application/json\", body, this.timeout, ontimeout, (resp) => {\r\n      this.reqs.delete(req);\r\n      if (this.isActive()) {\r\n        callback(resp);\r\n      }\r\n    });\r\n    this.reqs.add(req);\r\n  }\r\n};\r\n\r\n// js/phoenix/presence.js\r\nvar Presence = class {\r\n  constructor(channel, opts = {}) {\r\n    let events = opts.events || { state: \"presence_state\", diff: \"presence_diff\" };\r\n    this.state = {};\r\n    this.pendingDiffs = [];\r\n    this.channel = channel;\r\n    this.joinRef = null;\r\n    this.caller = {\r\n      onJoin: function() {\r\n      },\r\n      onLeave: function() {\r\n      },\r\n      onSync: function() {\r\n      }\r\n    };\r\n    this.channel.on(events.state, (newState) => {\r\n      let { onJoin, onLeave, onSync } = this.caller;\r\n      this.joinRef = this.channel.joinRef();\r\n      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\r\n      this.pendingDiffs.forEach((diff) => {\r\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\r\n      });\r\n      this.pendingDiffs = [];\r\n      onSync();\r\n    });\r\n    this.channel.on(events.diff, (diff) => {\r\n      let { onJoin, onLeave, onSync } = this.caller;\r\n      if (this.inPendingSyncState()) {\r\n        this.pendingDiffs.push(diff);\r\n      } else {\r\n        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\r\n        onSync();\r\n      }\r\n    });\r\n  }\r\n  onJoin(callback) {\r\n    this.caller.onJoin = callback;\r\n  }\r\n  onLeave(callback) {\r\n    this.caller.onLeave = callback;\r\n  }\r\n  onSync(callback) {\r\n    this.caller.onSync = callback;\r\n  }\r\n  list(by) {\r\n    return Presence.list(this.state, by);\r\n  }\r\n  inPendingSyncState() {\r\n    return !this.joinRef || this.joinRef !== this.channel.joinRef();\r\n  }\r\n  static syncState(currentState, newState, onJoin, onLeave) {\r\n    let state = this.clone(currentState);\r\n    let joins = {};\r\n    let leaves = {};\r\n    this.map(state, (key, presence) => {\r\n      if (!newState[key]) {\r\n        leaves[key] = presence;\r\n      }\r\n    });\r\n    this.map(newState, (key, newPresence) => {\r\n      let currentPresence = state[key];\r\n      if (currentPresence) {\r\n        let newRefs = newPresence.metas.map((m) => m.phx_ref);\r\n        let curRefs = currentPresence.metas.map((m) => m.phx_ref);\r\n        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);\r\n        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);\r\n        if (joinedMetas.length > 0) {\r\n          joins[key] = newPresence;\r\n          joins[key].metas = joinedMetas;\r\n        }\r\n        if (leftMetas.length > 0) {\r\n          leaves[key] = this.clone(currentPresence);\r\n          leaves[key].metas = leftMetas;\r\n        }\r\n      } else {\r\n        joins[key] = newPresence;\r\n      }\r\n    });\r\n    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\r\n  }\r\n  static syncDiff(state, diff, onJoin, onLeave) {\r\n    let { joins, leaves } = this.clone(diff);\r\n    if (!onJoin) {\r\n      onJoin = function() {\r\n      };\r\n    }\r\n    if (!onLeave) {\r\n      onLeave = function() {\r\n      };\r\n    }\r\n    this.map(joins, (key, newPresence) => {\r\n      let currentPresence = state[key];\r\n      state[key] = this.clone(newPresence);\r\n      if (currentPresence) {\r\n        let joinedRefs = state[key].metas.map((m) => m.phx_ref);\r\n        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);\r\n        state[key].metas.unshift(...curMetas);\r\n      }\r\n      onJoin(key, currentPresence, newPresence);\r\n    });\r\n    this.map(leaves, (key, leftPresence) => {\r\n      let currentPresence = state[key];\r\n      if (!currentPresence) {\r\n        return;\r\n      }\r\n      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);\r\n      currentPresence.metas = currentPresence.metas.filter((p) => {\r\n        return refsToRemove.indexOf(p.phx_ref) < 0;\r\n      });\r\n      onLeave(key, currentPresence, leftPresence);\r\n      if (currentPresence.metas.length === 0) {\r\n        delete state[key];\r\n      }\r\n    });\r\n    return state;\r\n  }\r\n  static list(presences, chooser) {\r\n    if (!chooser) {\r\n      chooser = function(key, pres) {\r\n        return pres;\r\n      };\r\n    }\r\n    return this.map(presences, (key, presence) => {\r\n      return chooser(key, presence);\r\n    });\r\n  }\r\n  static map(obj, func) {\r\n    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\r\n  }\r\n  static clone(obj) {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n};\r\n\r\n// js/phoenix/serializer.js\r\nvar serializer_default = {\r\n  HEADER_LENGTH: 1,\r\n  META_LENGTH: 4,\r\n  KINDS: { push: 0, reply: 1, broadcast: 2 },\r\n  encode(msg, callback) {\r\n    if (msg.payload.constructor === ArrayBuffer) {\r\n      return callback(this.binaryEncode(msg));\r\n    } else {\r\n      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\r\n      return callback(JSON.stringify(payload));\r\n    }\r\n  },\r\n  decode(rawPayload, callback) {\r\n    if (rawPayload.constructor === ArrayBuffer) {\r\n      return callback(this.binaryDecode(rawPayload));\r\n    } else {\r\n      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\r\n      return callback({ join_ref, ref, topic, event, payload });\r\n    }\r\n  },\r\n  binaryEncode(message) {\r\n    let { join_ref, ref, event, topic, payload } = message;\r\n    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\r\n    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\r\n    let view = new DataView(header);\r\n    let offset = 0;\r\n    view.setUint8(offset++, this.KINDS.push);\r\n    view.setUint8(offset++, join_ref.length);\r\n    view.setUint8(offset++, ref.length);\r\n    view.setUint8(offset++, topic.length);\r\n    view.setUint8(offset++, event.length);\r\n    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\r\n    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));\r\n    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));\r\n    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));\r\n    var combined = new Uint8Array(header.byteLength + payload.byteLength);\r\n    combined.set(new Uint8Array(header), 0);\r\n    combined.set(new Uint8Array(payload), header.byteLength);\r\n    return combined.buffer;\r\n  },\r\n  binaryDecode(buffer) {\r\n    let view = new DataView(buffer);\r\n    let kind = view.getUint8(0);\r\n    let decoder = new TextDecoder();\r\n    switch (kind) {\r\n      case this.KINDS.push:\r\n        return this.decodePush(buffer, view, decoder);\r\n      case this.KINDS.reply:\r\n        return this.decodeReply(buffer, view, decoder);\r\n      case this.KINDS.broadcast:\r\n        return this.decodeBroadcast(buffer, view, decoder);\r\n    }\r\n  },\r\n  decodePush(buffer, view, decoder) {\r\n    let joinRefSize = view.getUint8(1);\r\n    let topicSize = view.getUint8(2);\r\n    let eventSize = view.getUint8(3);\r\n    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\r\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\r\n    offset = offset + joinRefSize;\r\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\r\n    offset = offset + topicSize;\r\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\r\n    offset = offset + eventSize;\r\n    let data = buffer.slice(offset, buffer.byteLength);\r\n    return { join_ref: joinRef, ref: null, topic, event, payload: data };\r\n  },\r\n  decodeReply(buffer, view, decoder) {\r\n    let joinRefSize = view.getUint8(1);\r\n    let refSize = view.getUint8(2);\r\n    let topicSize = view.getUint8(3);\r\n    let eventSize = view.getUint8(4);\r\n    let offset = this.HEADER_LENGTH + this.META_LENGTH;\r\n    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\r\n    offset = offset + joinRefSize;\r\n    let ref = decoder.decode(buffer.slice(offset, offset + refSize));\r\n    offset = offset + refSize;\r\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\r\n    offset = offset + topicSize;\r\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\r\n    offset = offset + eventSize;\r\n    let data = buffer.slice(offset, buffer.byteLength);\r\n    let payload = { status: event, response: data };\r\n    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };\r\n  },\r\n  decodeBroadcast(buffer, view, decoder) {\r\n    let topicSize = view.getUint8(1);\r\n    let eventSize = view.getUint8(2);\r\n    let offset = this.HEADER_LENGTH + 2;\r\n    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\r\n    offset = offset + topicSize;\r\n    let event = decoder.decode(buffer.slice(offset, offset + eventSize));\r\n    offset = offset + eventSize;\r\n    let data = buffer.slice(offset, buffer.byteLength);\r\n    return { join_ref: null, ref: null, topic, event, payload: data };\r\n  }\r\n};\r\n\r\n// js/phoenix/socket.js\r\nvar Socket = class {\r\n  constructor(endPoint, opts = {}) {\r\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\r\n    this.channels = [];\r\n    this.sendBuffer = [];\r\n    this.ref = 0;\r\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\r\n    this.transport = opts.transport || global.WebSocket || LongPoll;\r\n    this.establishedConnections = 0;\r\n    this.defaultEncoder = serializer_default.encode.bind(serializer_default);\r\n    this.defaultDecoder = serializer_default.decode.bind(serializer_default);\r\n    this.closeWasClean = false;\r\n    this.binaryType = opts.binaryType || \"arraybuffer\";\r\n    this.connectClock = 1;\r\n    if (this.transport !== LongPoll) {\r\n      this.encode = opts.encode || this.defaultEncoder;\r\n      this.decode = opts.decode || this.defaultDecoder;\r\n    } else {\r\n      this.encode = this.defaultEncoder;\r\n      this.decode = this.defaultDecoder;\r\n    }\r\n    let awaitingConnectionOnPageShow = null;\r\n    if (phxWindow && phxWindow.addEventListener) {\r\n      phxWindow.addEventListener(\"pagehide\", (_e) => {\r\n        if (this.conn) {\r\n          this.disconnect();\r\n          awaitingConnectionOnPageShow = this.connectClock;\r\n        }\r\n      });\r\n      phxWindow.addEventListener(\"pageshow\", (_e) => {\r\n        if (awaitingConnectionOnPageShow === this.connectClock) {\r\n          awaitingConnectionOnPageShow = null;\r\n          this.connect();\r\n        }\r\n      });\r\n    }\r\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\r\n    this.rejoinAfterMs = (tries) => {\r\n      if (opts.rejoinAfterMs) {\r\n        return opts.rejoinAfterMs(tries);\r\n      } else {\r\n        return [1e3, 2e3, 5e3][tries - 1] || 1e4;\r\n      }\r\n    };\r\n    this.reconnectAfterMs = (tries) => {\r\n      if (opts.reconnectAfterMs) {\r\n        return opts.reconnectAfterMs(tries);\r\n      } else {\r\n        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\r\n      }\r\n    };\r\n    this.logger = opts.logger || null;\r\n    this.longpollerTimeout = opts.longpollerTimeout || 2e4;\r\n    this.params = closure(opts.params || {});\r\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\r\n    this.vsn = opts.vsn || DEFAULT_VSN;\r\n    this.heartbeatTimeoutTimer = null;\r\n    this.heartbeatTimer = null;\r\n    this.pendingHeartbeatRef = null;\r\n    this.reconnectTimer = new Timer(() => {\r\n      this.teardown(() => this.connect());\r\n    }, this.reconnectAfterMs);\r\n  }\r\n  getLongPollTransport() {\r\n    return LongPoll;\r\n  }\r\n  replaceTransport(newTransport) {\r\n    this.connectClock++;\r\n    this.closeWasClean = true;\r\n    this.reconnectTimer.reset();\r\n    this.sendBuffer = [];\r\n    if (this.conn) {\r\n      this.conn.close();\r\n      this.conn = null;\r\n    }\r\n    this.transport = newTransport;\r\n  }\r\n  protocol() {\r\n    return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\r\n  }\r\n  endPointURL() {\r\n    let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });\r\n    if (uri.charAt(0) !== \"/\") {\r\n      return uri;\r\n    }\r\n    if (uri.charAt(1) === \"/\") {\r\n      return `${this.protocol()}:${uri}`;\r\n    }\r\n    return `${this.protocol()}://${location.host}${uri}`;\r\n  }\r\n  disconnect(callback, code, reason) {\r\n    this.connectClock++;\r\n    this.closeWasClean = true;\r\n    this.reconnectTimer.reset();\r\n    this.teardown(callback, code, reason);\r\n  }\r\n  connect(params) {\r\n    if (params) {\r\n      console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\r\n      this.params = closure(params);\r\n    }\r\n    if (this.conn) {\r\n      return;\r\n    }\r\n    this.connectClock++;\r\n    this.closeWasClean = false;\r\n    this.conn = new this.transport(this.endPointURL());\r\n    this.conn.binaryType = this.binaryType;\r\n    this.conn.timeout = this.longpollerTimeout;\r\n    this.conn.onopen = () => this.onConnOpen();\r\n    this.conn.onerror = (error) => this.onConnError(error);\r\n    this.conn.onmessage = (event) => this.onConnMessage(event);\r\n    this.conn.onclose = (event) => this.onConnClose(event);\r\n  }\r\n  log(kind, msg, data) {\r\n    this.logger(kind, msg, data);\r\n  }\r\n  hasLogger() {\r\n    return this.logger !== null;\r\n  }\r\n  onOpen(callback) {\r\n    let ref = this.makeRef();\r\n    this.stateChangeCallbacks.open.push([ref, callback]);\r\n    return ref;\r\n  }\r\n  onClose(callback) {\r\n    let ref = this.makeRef();\r\n    this.stateChangeCallbacks.close.push([ref, callback]);\r\n    return ref;\r\n  }\r\n  onError(callback) {\r\n    let ref = this.makeRef();\r\n    this.stateChangeCallbacks.error.push([ref, callback]);\r\n    return ref;\r\n  }\r\n  onMessage(callback) {\r\n    let ref = this.makeRef();\r\n    this.stateChangeCallbacks.message.push([ref, callback]);\r\n    return ref;\r\n  }\r\n  ping(callback) {\r\n    if (!this.isConnected()) {\r\n      return false;\r\n    }\r\n    let ref = this.makeRef();\r\n    let startTime = Date.now();\r\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref });\r\n    let onMsgRef = this.onMessage((msg) => {\r\n      if (msg.ref === ref) {\r\n        this.off([onMsgRef]);\r\n        callback(Date.now() - startTime);\r\n      }\r\n    });\r\n    return true;\r\n  }\r\n  clearHeartbeats() {\r\n    clearTimeout(this.heartbeatTimer);\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n  }\r\n  onConnOpen() {\r\n    if (this.hasLogger())\r\n      this.log(\"transport\", `connected to ${this.endPointURL()}`);\r\n    this.closeWasClean = false;\r\n    this.establishedConnections++;\r\n    this.flushSendBuffer();\r\n    this.reconnectTimer.reset();\r\n    this.resetHeartbeat();\r\n    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\r\n  }\r\n  heartbeatTimeout() {\r\n    if (this.pendingHeartbeatRef) {\r\n      this.pendingHeartbeatRef = null;\r\n      if (this.hasLogger()) {\r\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\r\n      }\r\n      this.triggerChanError();\r\n      this.closeWasClean = false;\r\n      this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, \"heartbeat timeout\");\r\n    }\r\n  }\r\n  resetHeartbeat() {\r\n    if (this.conn && this.conn.skipHeartbeat) {\r\n      return;\r\n    }\r\n    this.pendingHeartbeatRef = null;\r\n    this.clearHeartbeats();\r\n    this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\r\n  }\r\n  teardown(callback, code, reason) {\r\n    if (!this.conn) {\r\n      return callback && callback();\r\n    }\r\n    this.waitForBufferDone(() => {\r\n      if (this.conn) {\r\n        if (code) {\r\n          this.conn.close(code, reason || \"\");\r\n        } else {\r\n          this.conn.close();\r\n        }\r\n      }\r\n      this.waitForSocketClosed(() => {\r\n        if (this.conn) {\r\n          this.conn.onopen = function() {\r\n          };\r\n          this.conn.onerror = function() {\r\n          };\r\n          this.conn.onmessage = function() {\r\n          };\r\n          this.conn.onclose = function() {\r\n          };\r\n          this.conn = null;\r\n        }\r\n        callback && callback();\r\n      });\r\n    });\r\n  }\r\n  waitForBufferDone(callback, tries = 1) {\r\n    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\r\n      callback();\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      this.waitForBufferDone(callback, tries + 1);\r\n    }, 150 * tries);\r\n  }\r\n  waitForSocketClosed(callback, tries = 1) {\r\n    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\r\n      callback();\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      this.waitForSocketClosed(callback, tries + 1);\r\n    }, 150 * tries);\r\n  }\r\n  onConnClose(event) {\r\n    let closeCode = event && event.code;\r\n    if (this.hasLogger())\r\n      this.log(\"transport\", \"close\", event);\r\n    this.triggerChanError();\r\n    this.clearHeartbeats();\r\n    if (!this.closeWasClean && closeCode !== 1e3) {\r\n      this.reconnectTimer.scheduleTimeout();\r\n    }\r\n    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\r\n  }\r\n  onConnError(error) {\r\n    if (this.hasLogger())\r\n      this.log(\"transport\", error);\r\n    let transportBefore = this.transport;\r\n    let establishedBefore = this.establishedConnections;\r\n    this.stateChangeCallbacks.error.forEach(([, callback]) => {\r\n      callback(error, transportBefore, establishedBefore);\r\n    });\r\n    if (transportBefore === this.transport || establishedBefore > 0) {\r\n      this.triggerChanError();\r\n    }\r\n  }\r\n  triggerChanError() {\r\n    this.channels.forEach((channel) => {\r\n      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\r\n        channel.trigger(CHANNEL_EVENTS.error);\r\n      }\r\n    });\r\n  }\r\n  connectionState() {\r\n    switch (this.conn && this.conn.readyState) {\r\n      case SOCKET_STATES.connecting:\r\n        return \"connecting\";\r\n      case SOCKET_STATES.open:\r\n        return \"open\";\r\n      case SOCKET_STATES.closing:\r\n        return \"closing\";\r\n      default:\r\n        return \"closed\";\r\n    }\r\n  }\r\n  isConnected() {\r\n    return this.connectionState() === \"open\";\r\n  }\r\n  remove(channel) {\r\n    this.off(channel.stateChangeRefs);\r\n    this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\r\n  }\r\n  off(refs) {\r\n    for (let key in this.stateChangeCallbacks) {\r\n      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\r\n        return refs.indexOf(ref) === -1;\r\n      });\r\n    }\r\n  }\r\n  channel(topic, chanParams = {}) {\r\n    let chan = new Channel(topic, chanParams, this);\r\n    this.channels.push(chan);\r\n    return chan;\r\n  }\r\n  push(data) {\r\n    if (this.hasLogger()) {\r\n      let { topic, event, payload, ref, join_ref } = data;\r\n      this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\r\n    }\r\n    if (this.isConnected()) {\r\n      this.encode(data, (result) => this.conn.send(result));\r\n    } else {\r\n      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));\r\n    }\r\n  }\r\n  makeRef() {\r\n    let newRef = this.ref + 1;\r\n    if (newRef === this.ref) {\r\n      this.ref = 0;\r\n    } else {\r\n      this.ref = newRef;\r\n    }\r\n    return this.ref.toString();\r\n  }\r\n  sendHeartbeat() {\r\n    if (this.pendingHeartbeatRef && !this.isConnected()) {\r\n      return;\r\n    }\r\n    this.pendingHeartbeatRef = this.makeRef();\r\n    this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\r\n    this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\r\n  }\r\n  flushSendBuffer() {\r\n    if (this.isConnected() && this.sendBuffer.length > 0) {\r\n      this.sendBuffer.forEach((callback) => callback());\r\n      this.sendBuffer = [];\r\n    }\r\n  }\r\n  onConnMessage(rawMessage) {\r\n    this.decode(rawMessage.data, (msg) => {\r\n      let { topic, event, payload, ref, join_ref } = msg;\r\n      if (ref && ref === this.pendingHeartbeatRef) {\r\n        this.clearHeartbeats();\r\n        this.pendingHeartbeatRef = null;\r\n        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\r\n      }\r\n      if (this.hasLogger())\r\n        this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\r\n      for (let i = 0; i < this.channels.length; i++) {\r\n        const channel = this.channels[i];\r\n        if (!channel.isMember(topic, event, payload, join_ref)) {\r\n          continue;\r\n        }\r\n        channel.trigger(event, payload, ref, join_ref);\r\n      }\r\n      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\r\n        let [, callback] = this.stateChangeCallbacks.message[i];\r\n        callback(msg);\r\n      }\r\n    });\r\n  }\r\n  leaveOpenTopic(topic) {\r\n    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\r\n    if (dupChannel) {\r\n      if (this.hasLogger())\r\n        this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\r\n      dupChannel.leave();\r\n    }\r\n  }\r\n};\r\nexport {\r\n  Channel,\r\n  LongPoll,\r\n  Presence,\r\n  serializer_default as Serializer,\r\n  Socket\r\n};\r\n//# sourceMappingURL=phoenix.mjs.map\r\n","\"use strict\";\r\n\r\n(function() {\r\n  var PolyfillEvent = eventConstructor();\r\n\r\n  function eventConstructor() {\r\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent;\r\n    // IE<=9 Support\r\n    function CustomEvent(event, params) {\r\n      params = params || {bubbles: false, cancelable: false, detail: undefined};\r\n      var evt = document.createEvent('CustomEvent');\r\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n      return evt;\r\n    }\r\n    CustomEvent.prototype = window.Event.prototype;\r\n    return CustomEvent;\r\n  }\r\n\r\n  function buildHiddenInput(name, value) {\r\n    var input = document.createElement(\"input\");\r\n    input.type = \"hidden\";\r\n    input.name = name;\r\n    input.value = value;\r\n    return input;\r\n  }\r\n\r\n  function handleClick(element, targetModifierKey) {\r\n    var to = element.getAttribute(\"data-to\"),\r\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\r\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\r\n        form = document.createElement(\"form\"),\r\n        target = element.getAttribute(\"target\");\r\n\r\n    form.method = (element.getAttribute(\"data-method\") === \"get\") ? \"get\" : \"post\";\r\n    form.action = to;\r\n    form.style.display = \"hidden\";\r\n\r\n    if (target) form.target = target;\r\n    else if (targetModifierKey) form.target = \"_blank\";\r\n\r\n    form.appendChild(csrf);\r\n    form.appendChild(method);\r\n    document.body.appendChild(form);\r\n    form.submit();\r\n  }\r\n\r\n  window.addEventListener(\"click\", function(e) {\r\n    var element = e.target;\r\n    if (e.defaultPrevented) return;\r\n\r\n    while (element && element.getAttribute) {\r\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\r\n        \"bubbles\": true, \"cancelable\": true\r\n      });\r\n\r\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\r\n        e.preventDefault();\r\n        e.stopImmediatePropagation();\r\n        return false;\r\n      }\r\n\r\n      if (element.getAttribute(\"data-method\")) {\r\n        handleClick(element, e.metaKey || e.shiftKey);\r\n        e.preventDefault();\r\n        return false;\r\n      } else {\r\n        element = element.parentNode;\r\n      }\r\n    }\r\n  }, false);\r\n\r\n  window.addEventListener('phoenix.link.click', function (e) {\r\n    var message = e.target.getAttribute(\"data-confirm\");\r\n    if(message && !window.confirm(message)) {\r\n      e.preventDefault();\r\n    }\r\n  }, false);\r\n})();\r\n","// js/phoenix_live_view/constants.js\r\nvar CONSECUTIVE_RELOADS = \"consecutive-reloads\";\r\nvar MAX_RELOADS = 10;\r\nvar RELOAD_JITTER_MIN = 5e3;\r\nvar RELOAD_JITTER_MAX = 1e4;\r\nvar FAILSAFE_JITTER = 3e4;\r\nvar PHX_EVENT_CLASSES = [\r\n  \"phx-click-loading\",\r\n  \"phx-change-loading\",\r\n  \"phx-submit-loading\",\r\n  \"phx-keydown-loading\",\r\n  \"phx-keyup-loading\",\r\n  \"phx-blur-loading\",\r\n  \"phx-focus-loading\"\r\n];\r\nvar PHX_COMPONENT = \"data-phx-component\";\r\nvar PHX_LIVE_LINK = \"data-phx-link\";\r\nvar PHX_TRACK_STATIC = \"track-static\";\r\nvar PHX_LINK_STATE = \"data-phx-link-state\";\r\nvar PHX_REF = \"data-phx-ref\";\r\nvar PHX_REF_SRC = \"data-phx-ref-src\";\r\nvar PHX_TRACK_UPLOADS = \"track-uploads\";\r\nvar PHX_UPLOAD_REF = \"data-phx-upload-ref\";\r\nvar PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\r\nvar PHX_DONE_REFS = \"data-phx-done-refs\";\r\nvar PHX_DROP_TARGET = \"drop-target\";\r\nvar PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\r\nvar PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\r\nvar PHX_SKIP = \"data-phx-skip\";\r\nvar PHX_PRUNE = \"data-phx-prune\";\r\nvar PHX_PAGE_LOADING = \"page-loading\";\r\nvar PHX_CONNECTED_CLASS = \"phx-connected\";\r\nvar PHX_DISCONNECTED_CLASS = \"phx-loading\";\r\nvar PHX_NO_FEEDBACK_CLASS = \"phx-no-feedback\";\r\nvar PHX_ERROR_CLASS = \"phx-error\";\r\nvar PHX_PARENT_ID = \"data-phx-parent-id\";\r\nvar PHX_MAIN = \"data-phx-main\";\r\nvar PHX_ROOT_ID = \"data-phx-root-id\";\r\nvar PHX_TRIGGER_ACTION = \"trigger-action\";\r\nvar PHX_FEEDBACK_FOR = \"feedback-for\";\r\nvar PHX_HAS_FOCUSED = \"phx-has-focused\";\r\nvar FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\", \"datetime-local\", \"color\", \"range\"];\r\nvar CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\r\nvar PHX_HAS_SUBMITTED = \"phx-has-submitted\";\r\nvar PHX_SESSION = \"data-phx-session\";\r\nvar PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\r\nvar PHX_STICKY = \"data-phx-sticky\";\r\nvar PHX_STATIC = \"data-phx-static\";\r\nvar PHX_READONLY = \"data-phx-readonly\";\r\nvar PHX_DISABLED = \"data-phx-disabled\";\r\nvar PHX_DISABLE_WITH = \"disable-with\";\r\nvar PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\r\nvar PHX_HOOK = \"hook\";\r\nvar PHX_DEBOUNCE = \"debounce\";\r\nvar PHX_THROTTLE = \"throttle\";\r\nvar PHX_UPDATE = \"update\";\r\nvar PHX_KEY = \"key\";\r\nvar PHX_PRIVATE = \"phxPrivate\";\r\nvar PHX_AUTO_RECOVER = \"auto-recover\";\r\nvar PHX_LV_DEBUG = \"phx:live-socket:debug\";\r\nvar PHX_LV_PROFILE = \"phx:live-socket:profiling\";\r\nvar PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\r\nvar PHX_PROGRESS = \"progress\";\r\nvar PHX_MOUNTED = \"mounted\";\r\nvar LOADER_TIMEOUT = 1;\r\nvar BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\r\nvar BINDING_PREFIX = \"phx-\";\r\nvar PUSH_TIMEOUT = 3e4;\r\nvar DEBOUNCE_TRIGGER = \"debounce-trigger\";\r\nvar THROTTLED = \"throttled\";\r\nvar DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\r\nvar DEFAULTS = {\r\n  debounce: 300,\r\n  throttle: 300\r\n};\r\nvar DYNAMICS = \"d\";\r\nvar STATIC = \"s\";\r\nvar COMPONENTS = \"c\";\r\nvar EVENTS = \"e\";\r\nvar REPLY = \"r\";\r\nvar TITLE = \"t\";\r\nvar TEMPLATES = \"p\";\r\n\r\n// js/phoenix_live_view/entry_uploader.js\r\nvar EntryUploader = class {\r\n  constructor(entry, chunkSize, liveSocket) {\r\n    this.liveSocket = liveSocket;\r\n    this.entry = entry;\r\n    this.offset = 0;\r\n    this.chunkSize = chunkSize;\r\n    this.chunkTimer = null;\r\n    this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, { token: entry.metadata() });\r\n  }\r\n  error(reason) {\r\n    clearTimeout(this.chunkTimer);\r\n    this.uploadChannel.leave();\r\n    this.entry.error(reason);\r\n  }\r\n  upload() {\r\n    this.uploadChannel.onError((reason) => this.error(reason));\r\n    this.uploadChannel.join().receive(\"ok\", (_data) => this.readNextChunk()).receive(\"error\", (reason) => this.error(reason));\r\n  }\r\n  isDone() {\r\n    return this.offset >= this.entry.file.size;\r\n  }\r\n  readNextChunk() {\r\n    let reader = new window.FileReader();\r\n    let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\r\n    reader.onload = (e) => {\r\n      if (e.target.error === null) {\r\n        this.offset += e.target.result.byteLength;\r\n        this.pushChunk(e.target.result);\r\n      } else {\r\n        return logError(\"Read error: \" + e.target.error);\r\n      }\r\n    };\r\n    reader.readAsArrayBuffer(blob);\r\n  }\r\n  pushChunk(chunk) {\r\n    if (!this.uploadChannel.isJoined()) {\r\n      return;\r\n    }\r\n    this.uploadChannel.push(\"chunk\", chunk).receive(\"ok\", () => {\r\n      this.entry.progress(this.offset / this.entry.file.size * 100);\r\n      if (!this.isDone()) {\r\n        this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/utils.js\r\nvar logError = (msg, obj) => console.error && console.error(msg, obj);\r\nvar isCid = (cid) => {\r\n  let type = typeof cid;\r\n  return type === \"number\" || type === \"string\" && /^(0|[1-9]\\d*)$/.test(cid);\r\n};\r\nfunction detectDuplicateIds() {\r\n  let ids = new Set();\r\n  let elems = document.querySelectorAll(\"*[id]\");\r\n  for (let i = 0, len = elems.length; i < len; i++) {\r\n    if (ids.has(elems[i].id)) {\r\n      console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);\r\n    } else {\r\n      ids.add(elems[i].id);\r\n    }\r\n  }\r\n}\r\nvar debug = (view, kind, msg, obj) => {\r\n  if (view.liveSocket.isDebugEnabled()) {\r\n    console.log(`${view.id} ${kind}: ${msg} - `, obj);\r\n  }\r\n};\r\nvar closure = (val) => typeof val === \"function\" ? val : function() {\r\n  return val;\r\n};\r\nvar clone = (obj) => {\r\n  return JSON.parse(JSON.stringify(obj));\r\n};\r\nvar closestPhxBinding = (el, binding, borderEl) => {\r\n  do {\r\n    if (el.matches(`[${binding}]`) && !el.disabled) {\r\n      return el;\r\n    }\r\n    el = el.parentElement || el.parentNode;\r\n  } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\r\n  return null;\r\n};\r\nvar isObject = (obj) => {\r\n  return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\r\n};\r\nvar isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);\r\nvar isEmpty = (obj) => {\r\n  for (let x in obj) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\nvar maybe = (el, callback) => el && callback(el);\r\nvar channelUploader = function(entries, onError, resp, liveSocket) {\r\n  entries.forEach((entry) => {\r\n    let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket);\r\n    entryUploader.upload();\r\n  });\r\n};\r\n\r\n// js/phoenix_live_view/browser.js\r\nvar Browser = {\r\n  canPushState() {\r\n    return typeof history.pushState !== \"undefined\";\r\n  },\r\n  dropLocal(localStorage, namespace, subkey) {\r\n    return localStorage.removeItem(this.localKey(namespace, subkey));\r\n  },\r\n  updateLocal(localStorage, namespace, subkey, initial, func) {\r\n    let current = this.getLocal(localStorage, namespace, subkey);\r\n    let key = this.localKey(namespace, subkey);\r\n    let newVal = current === null ? initial : func(current);\r\n    localStorage.setItem(key, JSON.stringify(newVal));\r\n    return newVal;\r\n  },\r\n  getLocal(localStorage, namespace, subkey) {\r\n    return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\r\n  },\r\n  updateCurrentState(callback) {\r\n    if (!this.canPushState()) {\r\n      return;\r\n    }\r\n    history.replaceState(callback(history.state || {}), \"\", window.location.href);\r\n  },\r\n  pushState(kind, meta, to) {\r\n    if (this.canPushState()) {\r\n      if (to !== window.location.href) {\r\n        if (meta.type == \"redirect\" && meta.scroll) {\r\n          let currentState = history.state || {};\r\n          currentState.scroll = meta.scroll;\r\n          history.replaceState(currentState, \"\", window.location.href);\r\n        }\r\n        delete meta.scroll;\r\n        history[kind + \"State\"](meta, \"\", to || null);\r\n        let hashEl = this.getHashTargetEl(window.location.hash);\r\n        if (hashEl) {\r\n          hashEl.scrollIntoView();\r\n        } else if (meta.type === \"redirect\") {\r\n          window.scroll(0, 0);\r\n        }\r\n      }\r\n    } else {\r\n      this.redirect(to);\r\n    }\r\n  },\r\n  setCookie(name, value) {\r\n    document.cookie = `${name}=${value}`;\r\n  },\r\n  getCookie(name) {\r\n    return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), \"$1\");\r\n  },\r\n  redirect(toURL, flash) {\r\n    if (flash) {\r\n      Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\r\n    }\r\n    window.location = toURL;\r\n  },\r\n  localKey(namespace, subkey) {\r\n    return `${namespace}-${subkey}`;\r\n  },\r\n  getHashTargetEl(maybeHash) {\r\n    let hash = maybeHash.toString().substring(1);\r\n    if (hash === \"\") {\r\n      return;\r\n    }\r\n    return document.getElementById(hash) || document.querySelector(`a[name=\"${hash}\"]`);\r\n  }\r\n};\r\nvar browser_default = Browser;\r\n\r\n// js/phoenix_live_view/dom.js\r\nvar DOM = {\r\n  byId(id) {\r\n    return document.getElementById(id) || logError(`no id found for ${id}`);\r\n  },\r\n  removeClass(el, className) {\r\n    el.classList.remove(className);\r\n    if (el.classList.length === 0) {\r\n      el.removeAttribute(\"class\");\r\n    }\r\n  },\r\n  all(node, query, callback) {\r\n    if (!node) {\r\n      return [];\r\n    }\r\n    let array = Array.from(node.querySelectorAll(query));\r\n    return callback ? array.forEach(callback) : array;\r\n  },\r\n  childNodeLength(html) {\r\n    let template = document.createElement(\"template\");\r\n    template.innerHTML = html;\r\n    return template.content.childElementCount;\r\n  },\r\n  isUploadInput(el) {\r\n    return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\r\n  },\r\n  findUploadInputs(node) {\r\n    return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`);\r\n  },\r\n  findComponentNodeList(node, cid) {\r\n    return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}=\"${cid}\"]`), node);\r\n  },\r\n  isPhxDestroyed(node) {\r\n    return node.id && DOM.private(node, \"destroyed\") ? true : false;\r\n  },\r\n  isExternalClick(e) {\r\n    return e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1 || e.target.getAttribute(\"target\") === \"_blank\";\r\n  },\r\n  markPhxChildDestroyed(el) {\r\n    if (this.isPhxChild(el)) {\r\n      el.setAttribute(PHX_SESSION, \"\");\r\n    }\r\n    this.putPrivate(el, \"destroyed\", true);\r\n  },\r\n  findPhxChildrenInFragment(html, parentId) {\r\n    let template = document.createElement(\"template\");\r\n    template.innerHTML = html;\r\n    return this.findPhxChildren(template.content, parentId);\r\n  },\r\n  isIgnored(el, phxUpdate) {\r\n    return (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) === \"ignore\";\r\n  },\r\n  isPhxUpdate(el, phxUpdate, updateTypes) {\r\n    return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\r\n  },\r\n  findPhxSticky(el) {\r\n    return this.all(el, `[${PHX_STICKY}]`);\r\n  },\r\n  findPhxChildren(el, parentId) {\r\n    return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\r\n  },\r\n  findParentCIDs(node, cids) {\r\n    let initial = new Set(cids);\r\n    let parentCids = cids.reduce((acc, cid) => {\r\n      let selector = `[${PHX_COMPONENT}=\"${cid}\"] [${PHX_COMPONENT}]`;\r\n      this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));\r\n      return acc;\r\n    }, initial);\r\n    return parentCids.size === 0 ? new Set(cids) : parentCids;\r\n  },\r\n  filterWithinSameLiveView(nodes, parent) {\r\n    if (parent.querySelector(PHX_VIEW_SELECTOR)) {\r\n      return nodes.filter((el) => this.withinSameLiveView(el, parent));\r\n    } else {\r\n      return nodes;\r\n    }\r\n  },\r\n  withinSameLiveView(node, parent) {\r\n    while (node = node.parentNode) {\r\n      if (node.isSameNode(parent)) {\r\n        return true;\r\n      }\r\n      if (node.getAttribute(PHX_SESSION) !== null) {\r\n        return false;\r\n      }\r\n    }\r\n  },\r\n  private(el, key) {\r\n    return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\r\n  },\r\n  deletePrivate(el, key) {\r\n    el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\r\n  },\r\n  putPrivate(el, key, value) {\r\n    if (!el[PHX_PRIVATE]) {\r\n      el[PHX_PRIVATE] = {};\r\n    }\r\n    el[PHX_PRIVATE][key] = value;\r\n  },\r\n  updatePrivate(el, key, defaultVal, updateFunc) {\r\n    let existing = this.private(el, key);\r\n    if (existing === void 0) {\r\n      this.putPrivate(el, key, updateFunc(defaultVal));\r\n    } else {\r\n      this.putPrivate(el, key, updateFunc(existing));\r\n    }\r\n  },\r\n  copyPrivates(target, source) {\r\n    if (source[PHX_PRIVATE]) {\r\n      target[PHX_PRIVATE] = source[PHX_PRIVATE];\r\n    }\r\n  },\r\n  putTitle(str) {\r\n    let titleEl = document.querySelector(\"title\");\r\n    let { prefix, suffix } = titleEl.dataset;\r\n    document.title = `${prefix || \"\"}${str}${suffix || \"\"}`;\r\n  },\r\n  debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {\r\n    let debounce = el.getAttribute(phxDebounce);\r\n    let throttle = el.getAttribute(phxThrottle);\r\n    if (debounce === \"\") {\r\n      debounce = defaultDebounce;\r\n    }\r\n    if (throttle === \"\") {\r\n      throttle = defaultThrottle;\r\n    }\r\n    let value = debounce || throttle;\r\n    switch (value) {\r\n      case null:\r\n        return callback();\r\n      case \"blur\":\r\n        if (this.once(el, \"debounce-blur\")) {\r\n          el.addEventListener(\"blur\", () => callback());\r\n        }\r\n        return;\r\n      default:\r\n        let timeout = parseInt(value);\r\n        let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();\r\n        let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\r\n        if (isNaN(timeout)) {\r\n          return logError(`invalid throttle/debounce value: ${value}`);\r\n        }\r\n        if (throttle) {\r\n          let newKeyDown = false;\r\n          if (event.type === \"keydown\") {\r\n            let prevKey = this.private(el, DEBOUNCE_PREV_KEY);\r\n            this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\r\n            newKeyDown = prevKey !== event.key;\r\n          }\r\n          if (!newKeyDown && this.private(el, THROTTLED)) {\r\n            return false;\r\n          } else {\r\n            callback();\r\n            this.putPrivate(el, THROTTLED, true);\r\n            setTimeout(() => {\r\n              if (asyncFilter()) {\r\n                this.triggerCycle(el, DEBOUNCE_TRIGGER);\r\n              }\r\n            }, timeout);\r\n          }\r\n        } else {\r\n          setTimeout(() => {\r\n            if (asyncFilter()) {\r\n              this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);\r\n            }\r\n          }, timeout);\r\n        }\r\n        let form = el.form;\r\n        if (form && this.once(form, \"bind-debounce\")) {\r\n          form.addEventListener(\"submit\", () => {\r\n            Array.from(new FormData(form).entries(), ([name]) => {\r\n              let input = form.querySelector(`[name=\"${name}\"]`);\r\n              this.incCycle(input, DEBOUNCE_TRIGGER);\r\n              this.deletePrivate(input, THROTTLED);\r\n            });\r\n          });\r\n        }\r\n        if (this.once(el, \"bind-debounce\")) {\r\n          el.addEventListener(\"blur\", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));\r\n        }\r\n    }\r\n  },\r\n  triggerCycle(el, key, currentCycle) {\r\n    let [cycle, trigger] = this.private(el, key);\r\n    if (!currentCycle) {\r\n      currentCycle = cycle;\r\n    }\r\n    if (currentCycle === cycle) {\r\n      this.incCycle(el, key);\r\n      trigger();\r\n    }\r\n  },\r\n  once(el, key) {\r\n    if (this.private(el, key) === true) {\r\n      return false;\r\n    }\r\n    this.putPrivate(el, key, true);\r\n    return true;\r\n  },\r\n  incCycle(el, key, trigger = function() {\r\n  }) {\r\n    let [currentCycle] = this.private(el, key) || [0, trigger];\r\n    currentCycle++;\r\n    this.putPrivate(el, key, [currentCycle, trigger]);\r\n    return currentCycle;\r\n  },\r\n  discardError(container, el, phxFeedbackFor) {\r\n    let field = el.getAttribute && el.getAttribute(phxFeedbackFor);\r\n    let input = field && container.querySelector(`[id=\"${field}\"], [name=\"${field}\"], [name=\"${field}[]\"]`);\r\n    if (!input) {\r\n      return;\r\n    }\r\n    if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input, PHX_HAS_SUBMITTED))) {\r\n      el.classList.add(PHX_NO_FEEDBACK_CLASS);\r\n    }\r\n  },\r\n  showError(inputEl, phxFeedbackFor) {\r\n    if (inputEl.id || inputEl.name) {\r\n      this.all(inputEl.form, `[${phxFeedbackFor}=\"${inputEl.id}\"], [${phxFeedbackFor}=\"${inputEl.name}\"]`, (el) => {\r\n        this.removeClass(el, PHX_NO_FEEDBACK_CLASS);\r\n      });\r\n    }\r\n  },\r\n  isPhxChild(node) {\r\n    return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\r\n  },\r\n  isPhxSticky(node) {\r\n    return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;\r\n  },\r\n  firstPhxChild(el) {\r\n    return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];\r\n  },\r\n  dispatchEvent(target, name, opts = {}) {\r\n    let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;\r\n    let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };\r\n    let event = name === \"click\" ? new MouseEvent(\"click\", eventOpts) : new CustomEvent(name, eventOpts);\r\n    target.dispatchEvent(event);\r\n  },\r\n  cloneNode(node, html) {\r\n    if (typeof html === \"undefined\") {\r\n      return node.cloneNode(true);\r\n    } else {\r\n      let cloned = node.cloneNode(false);\r\n      cloned.innerHTML = html;\r\n      return cloned;\r\n    }\r\n  },\r\n  mergeAttrs(target, source, opts = {}) {\r\n    let exclude = opts.exclude || [];\r\n    let isIgnored = opts.isIgnored;\r\n    let sourceAttrs = source.attributes;\r\n    for (let i = sourceAttrs.length - 1; i >= 0; i--) {\r\n      let name = sourceAttrs[i].name;\r\n      if (exclude.indexOf(name) < 0) {\r\n        target.setAttribute(name, source.getAttribute(name));\r\n      }\r\n    }\r\n    let targetAttrs = target.attributes;\r\n    for (let i = targetAttrs.length - 1; i >= 0; i--) {\r\n      let name = targetAttrs[i].name;\r\n      if (isIgnored) {\r\n        if (name.startsWith(\"data-\") && !source.hasAttribute(name)) {\r\n          target.removeAttribute(name);\r\n        }\r\n      } else {\r\n        if (!source.hasAttribute(name)) {\r\n          target.removeAttribute(name);\r\n        }\r\n      }\r\n    }\r\n  },\r\n  mergeFocusedInput(target, source) {\r\n    if (!(target instanceof HTMLSelectElement)) {\r\n      DOM.mergeAttrs(target, source, { exclude: [\"value\"] });\r\n    }\r\n    if (source.readOnly) {\r\n      target.setAttribute(\"readonly\", true);\r\n    } else {\r\n      target.removeAttribute(\"readonly\");\r\n    }\r\n  },\r\n  hasSelectionRange(el) {\r\n    return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\r\n  },\r\n  restoreFocus(focused, selectionStart, selectionEnd) {\r\n    if (!DOM.isTextualInput(focused)) {\r\n      return;\r\n    }\r\n    let wasFocused = focused.matches(\":focus\");\r\n    if (focused.readOnly) {\r\n      focused.blur();\r\n    }\r\n    if (!wasFocused) {\r\n      focused.focus();\r\n    }\r\n    if (this.hasSelectionRange(focused)) {\r\n      focused.setSelectionRange(selectionStart, selectionEnd);\r\n    }\r\n  },\r\n  isFormInput(el) {\r\n    return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\r\n  },\r\n  syncAttrsToProps(el) {\r\n    if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\r\n      el.checked = el.getAttribute(\"checked\") !== null;\r\n    }\r\n  },\r\n  isTextualInput(el) {\r\n    return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\r\n  },\r\n  isNowTriggerFormExternal(el, phxTriggerExternal) {\r\n    return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;\r\n  },\r\n  syncPendingRef(fromEl, toEl, disableWith) {\r\n    let ref = fromEl.getAttribute(PHX_REF);\r\n    if (ref === null) {\r\n      return true;\r\n    }\r\n    let refSrc = fromEl.getAttribute(PHX_REF_SRC);\r\n    if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {\r\n      if (DOM.isUploadInput(fromEl)) {\r\n        DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });\r\n      }\r\n      DOM.putPrivate(fromEl, PHX_REF, toEl);\r\n      return false;\r\n    } else {\r\n      PHX_EVENT_CLASSES.forEach((className) => {\r\n        fromEl.classList.contains(className) && toEl.classList.add(className);\r\n      });\r\n      toEl.setAttribute(PHX_REF, ref);\r\n      toEl.setAttribute(PHX_REF_SRC, refSrc);\r\n      return true;\r\n    }\r\n  },\r\n  cleanChildNodes(container, phxUpdate) {\r\n    if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\"])) {\r\n      let toRemove = [];\r\n      container.childNodes.forEach((childNode) => {\r\n        if (!childNode.id) {\r\n          let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\r\n          if (!isEmptyTextNode) {\r\n            logError(`only HTML element tags with an id are allowed inside containers with phx-update.\r\n\r\nremoving illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\r\n\r\n`);\r\n          }\r\n          toRemove.push(childNode);\r\n        }\r\n      });\r\n      toRemove.forEach((childNode) => childNode.remove());\r\n    }\r\n  },\r\n  replaceRootContainer(container, tagName, attrs) {\r\n    let retainedAttrs = new Set([\"id\", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);\r\n    if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\r\n      Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));\r\n      Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));\r\n      return container;\r\n    } else {\r\n      let newContainer = document.createElement(tagName);\r\n      Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));\r\n      retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));\r\n      newContainer.innerHTML = container.innerHTML;\r\n      container.replaceWith(newContainer);\r\n      return newContainer;\r\n    }\r\n  },\r\n  getSticky(el, name, defaultVal) {\r\n    let op = (DOM.private(el, \"sticky\") || []).find(([existingName]) => name === existingName);\r\n    if (op) {\r\n      let [_name, _op, stashedResult] = op;\r\n      return stashedResult;\r\n    } else {\r\n      return typeof defaultVal === \"function\" ? defaultVal() : defaultVal;\r\n    }\r\n  },\r\n  deleteSticky(el, name) {\r\n    this.updatePrivate(el, \"sticky\", [], (ops) => {\r\n      return ops.filter(([existingName, _]) => existingName !== name);\r\n    });\r\n  },\r\n  putSticky(el, name, op) {\r\n    let stashedResult = op(el);\r\n    this.updatePrivate(el, \"sticky\", [], (ops) => {\r\n      let existingIndex = ops.findIndex(([existingName]) => name === existingName);\r\n      if (existingIndex >= 0) {\r\n        ops[existingIndex] = [name, op, stashedResult];\r\n      } else {\r\n        ops.push([name, op, stashedResult]);\r\n      }\r\n      return ops;\r\n    });\r\n  },\r\n  applyStickyOperations(el) {\r\n    let ops = DOM.private(el, \"sticky\");\r\n    if (!ops) {\r\n      return;\r\n    }\r\n    ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));\r\n  }\r\n};\r\nvar dom_default = DOM;\r\n\r\n// js/phoenix_live_view/upload_entry.js\r\nvar UploadEntry = class {\r\n  static isActive(fileEl, file) {\r\n    let isNew = file._phxRef === void 0;\r\n    let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\r\n    let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\r\n    return file.size > 0 && (isNew || isActive);\r\n  }\r\n  static isPreflighted(fileEl, file) {\r\n    let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(\",\");\r\n    let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\r\n    return isPreflighted && this.isActive(fileEl, file);\r\n  }\r\n  constructor(fileEl, file, view) {\r\n    this.ref = LiveUploader.genFileRef(file);\r\n    this.fileEl = fileEl;\r\n    this.file = file;\r\n    this.view = view;\r\n    this.meta = null;\r\n    this._isCancelled = false;\r\n    this._isDone = false;\r\n    this._progress = 0;\r\n    this._lastProgressSent = -1;\r\n    this._onDone = function() {\r\n    };\r\n    this._onElUpdated = this.onElUpdated.bind(this);\r\n    this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\r\n  }\r\n  metadata() {\r\n    return this.meta;\r\n  }\r\n  progress(progress) {\r\n    this._progress = Math.floor(progress);\r\n    if (this._progress > this._lastProgressSent) {\r\n      if (this._progress >= 100) {\r\n        this._progress = 100;\r\n        this._lastProgressSent = 100;\r\n        this._isDone = true;\r\n        this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\r\n          LiveUploader.untrackFile(this.fileEl, this.file);\r\n          this._onDone();\r\n        });\r\n      } else {\r\n        this._lastProgressSent = this._progress;\r\n        this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\r\n      }\r\n    }\r\n  }\r\n  cancel() {\r\n    this._isCancelled = true;\r\n    this._isDone = true;\r\n    this._onDone();\r\n  }\r\n  isDone() {\r\n    return this._isDone;\r\n  }\r\n  error(reason = \"failed\") {\r\n    this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\r\n    this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });\r\n    LiveUploader.clearFiles(this.fileEl);\r\n  }\r\n  onDone(callback) {\r\n    this._onDone = () => {\r\n      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\r\n      callback();\r\n    };\r\n  }\r\n  onElUpdated() {\r\n    let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\r\n    if (activeRefs.indexOf(this.ref) === -1) {\r\n      this.cancel();\r\n    }\r\n  }\r\n  toPreflightPayload() {\r\n    return {\r\n      last_modified: this.file.lastModified,\r\n      name: this.file.name,\r\n      relative_path: this.file.webkitRelativePath,\r\n      size: this.file.size,\r\n      type: this.file.type,\r\n      ref: this.ref\r\n    };\r\n  }\r\n  uploader(uploaders) {\r\n    if (this.meta.uploader) {\r\n      let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);\r\n      return { name: this.meta.uploader, callback };\r\n    } else {\r\n      return { name: \"channel\", callback: channelUploader };\r\n    }\r\n  }\r\n  zipPostFlight(resp) {\r\n    this.meta = resp.entries[this.ref];\r\n    if (!this.meta) {\r\n      logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });\r\n    }\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/live_uploader.js\r\nvar liveUploaderFileRef = 0;\r\nvar LiveUploader = class {\r\n  static genFileRef(file) {\r\n    let ref = file._phxRef;\r\n    if (ref !== void 0) {\r\n      return ref;\r\n    } else {\r\n      file._phxRef = (liveUploaderFileRef++).toString();\r\n      return file._phxRef;\r\n    }\r\n  }\r\n  static getEntryDataURL(inputEl, ref, callback) {\r\n    let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);\r\n    callback(URL.createObjectURL(file));\r\n  }\r\n  static hasUploadsInProgress(formEl) {\r\n    let active = 0;\r\n    dom_default.findUploadInputs(formEl).forEach((input) => {\r\n      if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {\r\n        active++;\r\n      }\r\n    });\r\n    return active > 0;\r\n  }\r\n  static serializeUploads(inputEl) {\r\n    let files = this.activeFiles(inputEl);\r\n    let fileData = {};\r\n    files.forEach((file) => {\r\n      let entry = { path: inputEl.name };\r\n      let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\r\n      fileData[uploadRef] = fileData[uploadRef] || [];\r\n      entry.ref = this.genFileRef(file);\r\n      entry.last_modified = file.lastModified;\r\n      entry.name = file.name || entry.ref;\r\n      entry.relative_path = file.webkitRelativePath;\r\n      entry.type = file.type;\r\n      entry.size = file.size;\r\n      fileData[uploadRef].push(entry);\r\n    });\r\n    return fileData;\r\n  }\r\n  static clearFiles(inputEl) {\r\n    inputEl.value = null;\r\n    inputEl.removeAttribute(PHX_UPLOAD_REF);\r\n    dom_default.putPrivate(inputEl, \"files\", []);\r\n  }\r\n  static untrackFile(inputEl, file) {\r\n    dom_default.putPrivate(inputEl, \"files\", dom_default.private(inputEl, \"files\").filter((f) => !Object.is(f, file)));\r\n  }\r\n  static trackFiles(inputEl, files) {\r\n    if (inputEl.getAttribute(\"multiple\") !== null) {\r\n      let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));\r\n      dom_default.putPrivate(inputEl, \"files\", this.activeFiles(inputEl).concat(newFiles));\r\n      inputEl.value = null;\r\n    } else {\r\n      dom_default.putPrivate(inputEl, \"files\", files);\r\n    }\r\n  }\r\n  static activeFileInputs(formEl) {\r\n    let fileInputs = dom_default.findUploadInputs(formEl);\r\n    return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);\r\n  }\r\n  static activeFiles(input) {\r\n    return (dom_default.private(input, \"files\") || []).filter((f) => UploadEntry.isActive(input, f));\r\n  }\r\n  static inputsAwaitingPreflight(formEl) {\r\n    let fileInputs = dom_default.findUploadInputs(formEl);\r\n    return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);\r\n  }\r\n  static filesAwaitingPreflight(input) {\r\n    return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));\r\n  }\r\n  constructor(inputEl, view, onComplete) {\r\n    this.view = view;\r\n    this.onComplete = onComplete;\r\n    this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));\r\n    this.numEntriesInProgress = this._entries.length;\r\n  }\r\n  entries() {\r\n    return this._entries;\r\n  }\r\n  initAdapterUpload(resp, onError, liveSocket) {\r\n    this._entries = this._entries.map((entry) => {\r\n      entry.zipPostFlight(resp);\r\n      entry.onDone(() => {\r\n        this.numEntriesInProgress--;\r\n        if (this.numEntriesInProgress === 0) {\r\n          this.onComplete();\r\n        }\r\n      });\r\n      return entry;\r\n    });\r\n    let groupedEntries = this._entries.reduce((acc, entry) => {\r\n      let { name, callback } = entry.uploader(liveSocket.uploaders);\r\n      acc[name] = acc[name] || { callback, entries: [] };\r\n      acc[name].entries.push(entry);\r\n      return acc;\r\n    }, {});\r\n    for (let name in groupedEntries) {\r\n      let { callback, entries } = groupedEntries[name];\r\n      callback(entries, onError, resp, liveSocket);\r\n    }\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/aria.js\r\nvar ARIA = {\r\n  focusMain() {\r\n    let target = document.querySelector(\"main h1, main, h1\");\r\n    if (target) {\r\n      let origTabIndex = target.tabIndex;\r\n      target.tabIndex = -1;\r\n      target.focus();\r\n      target.tabIndex = origTabIndex;\r\n    }\r\n  },\r\n  anyOf(instance, classes) {\r\n    return classes.find((name) => instance instanceof name);\r\n  },\r\n  isFocusable(el, interactiveOnly) {\r\n    return el instanceof HTMLAnchorElement && el.rel !== \"ignore\" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLButtonElement]) || el instanceof HTMLIFrameElement || (el.tabIndex > 0 || !interactiveOnly && el.tabIndex === 0 && el.getAttribute(\"tabindex\") !== null && el.getAttribute(\"aria-hidden\") !== \"true\");\r\n  },\r\n  attemptFocus(el, interactiveOnly) {\r\n    if (this.isFocusable(el, interactiveOnly)) {\r\n      try {\r\n        el.focus();\r\n      } catch (e) {\r\n      }\r\n    }\r\n    return !!document.activeElement && document.activeElement.isSameNode(el);\r\n  },\r\n  focusFirstInteractive(el) {\r\n    let child = el.firstElementChild;\r\n    while (child) {\r\n      if (this.attemptFocus(child, true) || this.focusFirstInteractive(child, true)) {\r\n        return true;\r\n      }\r\n      child = child.nextElementSibling;\r\n    }\r\n  },\r\n  focusFirst(el) {\r\n    let child = el.firstElementChild;\r\n    while (child) {\r\n      if (this.attemptFocus(child) || this.focusFirst(child)) {\r\n        return true;\r\n      }\r\n      child = child.nextElementSibling;\r\n    }\r\n  },\r\n  focusLast(el) {\r\n    let child = el.lastElementChild;\r\n    while (child) {\r\n      if (this.attemptFocus(child) || this.focusLast(child)) {\r\n        return true;\r\n      }\r\n      child = child.previousElementSibling;\r\n    }\r\n  }\r\n};\r\nvar aria_default = ARIA;\r\n\r\n// js/phoenix_live_view/hooks.js\r\nvar Hooks = {\r\n  LiveFileUpload: {\r\n    activeRefs() {\r\n      return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\r\n    },\r\n    preflightedRefs() {\r\n      return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\r\n    },\r\n    mounted() {\r\n      this.preflightedWas = this.preflightedRefs();\r\n    },\r\n    updated() {\r\n      let newPreflights = this.preflightedRefs();\r\n      if (this.preflightedWas !== newPreflights) {\r\n        this.preflightedWas = newPreflights;\r\n        if (newPreflights === \"\") {\r\n          this.__view.cancelSubmit(this.el.form);\r\n        }\r\n      }\r\n      if (this.activeRefs() === \"\") {\r\n        this.el.value = null;\r\n      }\r\n      this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\r\n    }\r\n  },\r\n  LiveImgPreview: {\r\n    mounted() {\r\n      this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\r\n      this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));\r\n      LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {\r\n        this.url = url;\r\n        this.el.src = url;\r\n      });\r\n    },\r\n    destroyed() {\r\n      URL.revokeObjectURL(this.url);\r\n    }\r\n  },\r\n  FocusWrap: {\r\n    mounted() {\r\n      this.focusStart = this.el.firstElementChild;\r\n      this.focusEnd = this.el.lastElementChild;\r\n      this.focusStart.addEventListener(\"focus\", () => aria_default.focusLast(this.el));\r\n      this.focusEnd.addEventListener(\"focus\", () => aria_default.focusFirst(this.el));\r\n      this.el.addEventListener(\"phx:show-end\", () => this.el.focus());\r\n      if (window.getComputedStyle(this.el).display !== \"none\") {\r\n        aria_default.focusFirst(this.el);\r\n      }\r\n    }\r\n  }\r\n};\r\nvar hooks_default = Hooks;\r\n\r\n// js/phoenix_live_view/dom_post_morph_restorer.js\r\nvar DOMPostMorphRestorer = class {\r\n  constructor(containerBefore, containerAfter, updateType) {\r\n    let idsBefore = new Set();\r\n    let idsAfter = new Set([...containerAfter.children].map((child) => child.id));\r\n    let elementsToModify = [];\r\n    Array.from(containerBefore.children).forEach((child) => {\r\n      if (child.id) {\r\n        idsBefore.add(child.id);\r\n        if (idsAfter.has(child.id)) {\r\n          let previousElementId = child.previousElementSibling && child.previousElementSibling.id;\r\n          elementsToModify.push({ elementId: child.id, previousElementId });\r\n        }\r\n      }\r\n    });\r\n    this.containerId = containerAfter.id;\r\n    this.updateType = updateType;\r\n    this.elementsToModify = elementsToModify;\r\n    this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));\r\n  }\r\n  perform() {\r\n    let container = dom_default.byId(this.containerId);\r\n    this.elementsToModify.forEach((elementToModify) => {\r\n      if (elementToModify.previousElementId) {\r\n        maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {\r\n          maybe(document.getElementById(elementToModify.elementId), (elem) => {\r\n            let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\r\n            if (!isInRightPlace) {\r\n              previousElem.insertAdjacentElement(\"afterend\", elem);\r\n            }\r\n          });\r\n        });\r\n      } else {\r\n        maybe(document.getElementById(elementToModify.elementId), (elem) => {\r\n          let isInRightPlace = elem.previousElementSibling == null;\r\n          if (!isInRightPlace) {\r\n            container.insertAdjacentElement(\"afterbegin\", elem);\r\n          }\r\n        });\r\n      }\r\n    });\r\n    if (this.updateType == \"prepend\") {\r\n      this.elementIdsToAdd.reverse().forEach((elemId) => {\r\n        maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement(\"afterbegin\", elem));\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\n// node_modules/morphdom/dist/morphdom-esm.js\r\nvar DOCUMENT_FRAGMENT_NODE = 11;\r\nfunction morphAttrs(fromNode, toNode) {\r\n  var toNodeAttrs = toNode.attributes;\r\n  var attr;\r\n  var attrName;\r\n  var attrNamespaceURI;\r\n  var attrValue;\r\n  var fromValue;\r\n  if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\r\n    return;\r\n  }\r\n  for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\r\n    attr = toNodeAttrs[i];\r\n    attrName = attr.name;\r\n    attrNamespaceURI = attr.namespaceURI;\r\n    attrValue = attr.value;\r\n    if (attrNamespaceURI) {\r\n      attrName = attr.localName || attrName;\r\n      fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\r\n      if (fromValue !== attrValue) {\r\n        if (attr.prefix === \"xmlns\") {\r\n          attrName = attr.name;\r\n        }\r\n        fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\r\n      }\r\n    } else {\r\n      fromValue = fromNode.getAttribute(attrName);\r\n      if (fromValue !== attrValue) {\r\n        fromNode.setAttribute(attrName, attrValue);\r\n      }\r\n    }\r\n  }\r\n  var fromNodeAttrs = fromNode.attributes;\r\n  for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\r\n    attr = fromNodeAttrs[d];\r\n    attrName = attr.name;\r\n    attrNamespaceURI = attr.namespaceURI;\r\n    if (attrNamespaceURI) {\r\n      attrName = attr.localName || attrName;\r\n      if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\r\n        fromNode.removeAttributeNS(attrNamespaceURI, attrName);\r\n      }\r\n    } else {\r\n      if (!toNode.hasAttribute(attrName)) {\r\n        fromNode.removeAttribute(attrName);\r\n      }\r\n    }\r\n  }\r\n}\r\nvar range;\r\nvar NS_XHTML = \"http://www.w3.org/1999/xhtml\";\r\nvar doc = typeof document === \"undefined\" ? void 0 : document;\r\nvar HAS_TEMPLATE_SUPPORT = !!doc && \"content\" in doc.createElement(\"template\");\r\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && \"createContextualFragment\" in doc.createRange();\r\nfunction createFragmentFromTemplate(str) {\r\n  var template = doc.createElement(\"template\");\r\n  template.innerHTML = str;\r\n  return template.content.childNodes[0];\r\n}\r\nfunction createFragmentFromRange(str) {\r\n  if (!range) {\r\n    range = doc.createRange();\r\n    range.selectNode(doc.body);\r\n  }\r\n  var fragment = range.createContextualFragment(str);\r\n  return fragment.childNodes[0];\r\n}\r\nfunction createFragmentFromWrap(str) {\r\n  var fragment = doc.createElement(\"body\");\r\n  fragment.innerHTML = str;\r\n  return fragment.childNodes[0];\r\n}\r\nfunction toElement(str) {\r\n  str = str.trim();\r\n  if (HAS_TEMPLATE_SUPPORT) {\r\n    return createFragmentFromTemplate(str);\r\n  } else if (HAS_RANGE_SUPPORT) {\r\n    return createFragmentFromRange(str);\r\n  }\r\n  return createFragmentFromWrap(str);\r\n}\r\nfunction compareNodeNames(fromEl, toEl) {\r\n  var fromNodeName = fromEl.nodeName;\r\n  var toNodeName = toEl.nodeName;\r\n  var fromCodeStart, toCodeStart;\r\n  if (fromNodeName === toNodeName) {\r\n    return true;\r\n  }\r\n  fromCodeStart = fromNodeName.charCodeAt(0);\r\n  toCodeStart = toNodeName.charCodeAt(0);\r\n  if (fromCodeStart <= 90 && toCodeStart >= 97) {\r\n    return fromNodeName === toNodeName.toUpperCase();\r\n  } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\r\n    return toNodeName === fromNodeName.toUpperCase();\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\nfunction createElementNS(name, namespaceURI) {\r\n  return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\r\n}\r\nfunction moveChildren(fromEl, toEl) {\r\n  var curChild = fromEl.firstChild;\r\n  while (curChild) {\r\n    var nextChild = curChild.nextSibling;\r\n    toEl.appendChild(curChild);\r\n    curChild = nextChild;\r\n  }\r\n  return toEl;\r\n}\r\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\r\n  if (fromEl[name] !== toEl[name]) {\r\n    fromEl[name] = toEl[name];\r\n    if (fromEl[name]) {\r\n      fromEl.setAttribute(name, \"\");\r\n    } else {\r\n      fromEl.removeAttribute(name);\r\n    }\r\n  }\r\n}\r\nvar specialElHandlers = {\r\n  OPTION: function(fromEl, toEl) {\r\n    var parentNode = fromEl.parentNode;\r\n    if (parentNode) {\r\n      var parentName = parentNode.nodeName.toUpperCase();\r\n      if (parentName === \"OPTGROUP\") {\r\n        parentNode = parentNode.parentNode;\r\n        parentName = parentNode && parentNode.nodeName.toUpperCase();\r\n      }\r\n      if (parentName === \"SELECT\" && !parentNode.hasAttribute(\"multiple\")) {\r\n        if (fromEl.hasAttribute(\"selected\") && !toEl.selected) {\r\n          fromEl.setAttribute(\"selected\", \"selected\");\r\n          fromEl.removeAttribute(\"selected\");\r\n        }\r\n        parentNode.selectedIndex = -1;\r\n      }\r\n    }\r\n    syncBooleanAttrProp(fromEl, toEl, \"selected\");\r\n  },\r\n  INPUT: function(fromEl, toEl) {\r\n    syncBooleanAttrProp(fromEl, toEl, \"checked\");\r\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\r\n    if (fromEl.value !== toEl.value) {\r\n      fromEl.value = toEl.value;\r\n    }\r\n    if (!toEl.hasAttribute(\"value\")) {\r\n      fromEl.removeAttribute(\"value\");\r\n    }\r\n  },\r\n  TEXTAREA: function(fromEl, toEl) {\r\n    var newValue = toEl.value;\r\n    if (fromEl.value !== newValue) {\r\n      fromEl.value = newValue;\r\n    }\r\n    var firstChild = fromEl.firstChild;\r\n    if (firstChild) {\r\n      var oldValue = firstChild.nodeValue;\r\n      if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\r\n        return;\r\n      }\r\n      firstChild.nodeValue = newValue;\r\n    }\r\n  },\r\n  SELECT: function(fromEl, toEl) {\r\n    if (!toEl.hasAttribute(\"multiple\")) {\r\n      var selectedIndex = -1;\r\n      var i = 0;\r\n      var curChild = fromEl.firstChild;\r\n      var optgroup;\r\n      var nodeName;\r\n      while (curChild) {\r\n        nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\r\n        if (nodeName === \"OPTGROUP\") {\r\n          optgroup = curChild;\r\n          curChild = optgroup.firstChild;\r\n        } else {\r\n          if (nodeName === \"OPTION\") {\r\n            if (curChild.hasAttribute(\"selected\")) {\r\n              selectedIndex = i;\r\n              break;\r\n            }\r\n            i++;\r\n          }\r\n          curChild = curChild.nextSibling;\r\n          if (!curChild && optgroup) {\r\n            curChild = optgroup.nextSibling;\r\n            optgroup = null;\r\n          }\r\n        }\r\n      }\r\n      fromEl.selectedIndex = selectedIndex;\r\n    }\r\n  }\r\n};\r\nvar ELEMENT_NODE = 1;\r\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\r\nvar TEXT_NODE = 3;\r\nvar COMMENT_NODE = 8;\r\nfunction noop() {\r\n}\r\nfunction defaultGetNodeKey(node) {\r\n  if (node) {\r\n    return node.getAttribute && node.getAttribute(\"id\") || node.id;\r\n  }\r\n}\r\nfunction morphdomFactory(morphAttrs2) {\r\n  return function morphdom2(fromNode, toNode, options) {\r\n    if (!options) {\r\n      options = {};\r\n    }\r\n    if (typeof toNode === \"string\") {\r\n      if (fromNode.nodeName === \"#document\" || fromNode.nodeName === \"HTML\" || fromNode.nodeName === \"BODY\") {\r\n        var toNodeHtml = toNode;\r\n        toNode = doc.createElement(\"html\");\r\n        toNode.innerHTML = toNodeHtml;\r\n      } else {\r\n        toNode = toElement(toNode);\r\n      }\r\n    }\r\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\r\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\r\n    var onNodeAdded = options.onNodeAdded || noop;\r\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\r\n    var onElUpdated = options.onElUpdated || noop;\r\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\r\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\r\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\r\n    var childrenOnly = options.childrenOnly === true;\r\n    var fromNodesLookup = Object.create(null);\r\n    var keyedRemovalList = [];\r\n    function addKeyedRemoval(key) {\r\n      keyedRemovalList.push(key);\r\n    }\r\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\r\n      if (node.nodeType === ELEMENT_NODE) {\r\n        var curChild = node.firstChild;\r\n        while (curChild) {\r\n          var key = void 0;\r\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\r\n            addKeyedRemoval(key);\r\n          } else {\r\n            onNodeDiscarded(curChild);\r\n            if (curChild.firstChild) {\r\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\r\n            }\r\n          }\r\n          curChild = curChild.nextSibling;\r\n        }\r\n      }\r\n    }\r\n    function removeNode(node, parentNode, skipKeyedNodes) {\r\n      if (onBeforeNodeDiscarded(node) === false) {\r\n        return;\r\n      }\r\n      if (parentNode) {\r\n        parentNode.removeChild(node);\r\n      }\r\n      onNodeDiscarded(node);\r\n      walkDiscardedChildNodes(node, skipKeyedNodes);\r\n    }\r\n    function indexTree(node) {\r\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\r\n        var curChild = node.firstChild;\r\n        while (curChild) {\r\n          var key = getNodeKey(curChild);\r\n          if (key) {\r\n            fromNodesLookup[key] = curChild;\r\n          }\r\n          indexTree(curChild);\r\n          curChild = curChild.nextSibling;\r\n        }\r\n      }\r\n    }\r\n    indexTree(fromNode);\r\n    function handleNodeAdded(el) {\r\n      onNodeAdded(el);\r\n      var curChild = el.firstChild;\r\n      while (curChild) {\r\n        var nextSibling = curChild.nextSibling;\r\n        var key = getNodeKey(curChild);\r\n        if (key) {\r\n          var unmatchedFromEl = fromNodesLookup[key];\r\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\r\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\r\n            morphEl(unmatchedFromEl, curChild);\r\n          } else {\r\n            handleNodeAdded(curChild);\r\n          }\r\n        } else {\r\n          handleNodeAdded(curChild);\r\n        }\r\n        curChild = nextSibling;\r\n      }\r\n    }\r\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\r\n      while (curFromNodeChild) {\r\n        var fromNextSibling = curFromNodeChild.nextSibling;\r\n        if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\r\n          addKeyedRemoval(curFromNodeKey);\r\n        } else {\r\n          removeNode(curFromNodeChild, fromEl, true);\r\n        }\r\n        curFromNodeChild = fromNextSibling;\r\n      }\r\n    }\r\n    function morphEl(fromEl, toEl, childrenOnly2) {\r\n      var toElKey = getNodeKey(toEl);\r\n      if (toElKey) {\r\n        delete fromNodesLookup[toElKey];\r\n      }\r\n      if (!childrenOnly2) {\r\n        if (onBeforeElUpdated(fromEl, toEl) === false) {\r\n          return;\r\n        }\r\n        morphAttrs2(fromEl, toEl);\r\n        onElUpdated(fromEl);\r\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\r\n          return;\r\n        }\r\n      }\r\n      if (fromEl.nodeName !== \"TEXTAREA\") {\r\n        morphChildren(fromEl, toEl);\r\n      } else {\r\n        specialElHandlers.TEXTAREA(fromEl, toEl);\r\n      }\r\n    }\r\n    function morphChildren(fromEl, toEl) {\r\n      var curToNodeChild = toEl.firstChild;\r\n      var curFromNodeChild = fromEl.firstChild;\r\n      var curToNodeKey;\r\n      var curFromNodeKey;\r\n      var fromNextSibling;\r\n      var toNextSibling;\r\n      var matchingFromEl;\r\n      outer:\r\n        while (curToNodeChild) {\r\n          toNextSibling = curToNodeChild.nextSibling;\r\n          curToNodeKey = getNodeKey(curToNodeChild);\r\n          while (curFromNodeChild) {\r\n            fromNextSibling = curFromNodeChild.nextSibling;\r\n            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\r\n              curToNodeChild = toNextSibling;\r\n              curFromNodeChild = fromNextSibling;\r\n              continue outer;\r\n            }\r\n            curFromNodeKey = getNodeKey(curFromNodeChild);\r\n            var curFromNodeType = curFromNodeChild.nodeType;\r\n            var isCompatible = void 0;\r\n            if (curFromNodeType === curToNodeChild.nodeType) {\r\n              if (curFromNodeType === ELEMENT_NODE) {\r\n                if (curToNodeKey) {\r\n                  if (curToNodeKey !== curFromNodeKey) {\r\n                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\r\n                      if (fromNextSibling === matchingFromEl) {\r\n                        isCompatible = false;\r\n                      } else {\r\n                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);\r\n                        if (curFromNodeKey) {\r\n                          addKeyedRemoval(curFromNodeKey);\r\n                        } else {\r\n                          removeNode(curFromNodeChild, fromEl, true);\r\n                        }\r\n                        curFromNodeChild = matchingFromEl;\r\n                      }\r\n                    } else {\r\n                      isCompatible = false;\r\n                    }\r\n                  }\r\n                } else if (curFromNodeKey) {\r\n                  isCompatible = false;\r\n                }\r\n                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\r\n                if (isCompatible) {\r\n                  morphEl(curFromNodeChild, curToNodeChild);\r\n                }\r\n              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\r\n                isCompatible = true;\r\n                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\r\n                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\r\n                }\r\n              }\r\n            }\r\n            if (isCompatible) {\r\n              curToNodeChild = toNextSibling;\r\n              curFromNodeChild = fromNextSibling;\r\n              continue outer;\r\n            }\r\n            if (curFromNodeKey) {\r\n              addKeyedRemoval(curFromNodeKey);\r\n            } else {\r\n              removeNode(curFromNodeChild, fromEl, true);\r\n            }\r\n            curFromNodeChild = fromNextSibling;\r\n          }\r\n          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\r\n            fromEl.appendChild(matchingFromEl);\r\n            morphEl(matchingFromEl, curToNodeChild);\r\n          } else {\r\n            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\r\n            if (onBeforeNodeAddedResult !== false) {\r\n              if (onBeforeNodeAddedResult) {\r\n                curToNodeChild = onBeforeNodeAddedResult;\r\n              }\r\n              if (curToNodeChild.actualize) {\r\n                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\r\n              }\r\n              fromEl.appendChild(curToNodeChild);\r\n              handleNodeAdded(curToNodeChild);\r\n            }\r\n          }\r\n          curToNodeChild = toNextSibling;\r\n          curFromNodeChild = fromNextSibling;\r\n        }\r\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\r\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\r\n      if (specialElHandler) {\r\n        specialElHandler(fromEl, toEl);\r\n      }\r\n    }\r\n    var morphedNode = fromNode;\r\n    var morphedNodeType = morphedNode.nodeType;\r\n    var toNodeType = toNode.nodeType;\r\n    if (!childrenOnly) {\r\n      if (morphedNodeType === ELEMENT_NODE) {\r\n        if (toNodeType === ELEMENT_NODE) {\r\n          if (!compareNodeNames(fromNode, toNode)) {\r\n            onNodeDiscarded(fromNode);\r\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\r\n          }\r\n        } else {\r\n          morphedNode = toNode;\r\n        }\r\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\r\n        if (toNodeType === morphedNodeType) {\r\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\r\n            morphedNode.nodeValue = toNode.nodeValue;\r\n          }\r\n          return morphedNode;\r\n        } else {\r\n          morphedNode = toNode;\r\n        }\r\n      }\r\n    }\r\n    if (morphedNode === toNode) {\r\n      onNodeDiscarded(fromNode);\r\n    } else {\r\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\r\n        return;\r\n      }\r\n      morphEl(morphedNode, toNode, childrenOnly);\r\n      if (keyedRemovalList) {\r\n        for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\r\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\r\n          if (elToRemove) {\r\n            removeNode(elToRemove, elToRemove.parentNode, false);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\r\n      if (morphedNode.actualize) {\r\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\r\n      }\r\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\r\n    }\r\n    return morphedNode;\r\n  };\r\n}\r\nvar morphdom = morphdomFactory(morphAttrs);\r\nvar morphdom_esm_default = morphdom;\r\n\r\n// js/phoenix_live_view/dom_patch.js\r\nvar DOMPatch = class {\r\n  static patchEl(fromEl, toEl, activeElement) {\r\n    morphdom_esm_default(fromEl, toEl, {\r\n      childrenOnly: false,\r\n      onBeforeElUpdated: (fromEl2, toEl2) => {\r\n        if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {\r\n          dom_default.mergeFocusedInput(fromEl2, toEl2);\r\n          return false;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  constructor(view, container, id, html, targetCID) {\r\n    this.view = view;\r\n    this.liveSocket = view.liveSocket;\r\n    this.container = container;\r\n    this.id = id;\r\n    this.rootID = view.root.id;\r\n    this.html = html;\r\n    this.targetCID = targetCID;\r\n    this.cidPatch = isCid(this.targetCID);\r\n    this.callbacks = {\r\n      beforeadded: [],\r\n      beforeupdated: [],\r\n      beforephxChildAdded: [],\r\n      afteradded: [],\r\n      afterupdated: [],\r\n      afterdiscarded: [],\r\n      afterphxChildAdded: [],\r\n      aftertransitionsDiscarded: []\r\n    };\r\n  }\r\n  before(kind, callback) {\r\n    this.callbacks[`before${kind}`].push(callback);\r\n  }\r\n  after(kind, callback) {\r\n    this.callbacks[`after${kind}`].push(callback);\r\n  }\r\n  trackBefore(kind, ...args) {\r\n    this.callbacks[`before${kind}`].forEach((callback) => callback(...args));\r\n  }\r\n  trackAfter(kind, ...args) {\r\n    this.callbacks[`after${kind}`].forEach((callback) => callback(...args));\r\n  }\r\n  markPrunableContentForRemoval() {\r\n    dom_default.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", (el) => {\r\n      el.setAttribute(PHX_PRUNE, \"\");\r\n    });\r\n  }\r\n  perform() {\r\n    let { view, liveSocket, container, html } = this;\r\n    let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;\r\n    if (this.isCIDPatch() && !targetContainer) {\r\n      return;\r\n    }\r\n    let focused = liveSocket.getActiveElement();\r\n    let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};\r\n    let phxUpdate = liveSocket.binding(PHX_UPDATE);\r\n    let phxFeedbackFor = liveSocket.binding(PHX_FEEDBACK_FOR);\r\n    let disableWith = liveSocket.binding(PHX_DISABLE_WITH);\r\n    let phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\r\n    let phxRemove = liveSocket.binding(\"remove\");\r\n    let added = [];\r\n    let updates = [];\r\n    let appendPrependUpdates = [];\r\n    let pendingRemoves = [];\r\n    let externalFormTriggered = null;\r\n    let diffHTML = liveSocket.time(\"premorph container prep\", () => {\r\n      return this.buildDiffHTML(container, html, phxUpdate, targetContainer);\r\n    });\r\n    this.trackBefore(\"added\", container);\r\n    this.trackBefore(\"updated\", container, container);\r\n    liveSocket.time(\"morphdom\", () => {\r\n      morphdom_esm_default(targetContainer, diffHTML, {\r\n        childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,\r\n        getNodeKey: (node) => {\r\n          return dom_default.isPhxDestroyed(node) ? null : node.id;\r\n        },\r\n        onBeforeNodeAdded: (el) => {\r\n          this.trackBefore(\"added\", el);\r\n          return el;\r\n        },\r\n        onNodeAdded: (el) => {\r\n          if (el instanceof HTMLImageElement && el.srcset) {\r\n            el.srcset = el.srcset;\r\n          } else if (el instanceof HTMLVideoElement && el.autoplay) {\r\n            el.play();\r\n          }\r\n          if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\r\n            externalFormTriggered = el;\r\n          }\r\n          dom_default.discardError(targetContainer, el, phxFeedbackFor);\r\n          if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {\r\n            this.trackAfter(\"phxChildAdded\", el);\r\n          }\r\n          added.push(el);\r\n        },\r\n        onNodeDiscarded: (el) => {\r\n          if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {\r\n            liveSocket.destroyViewByEl(el);\r\n          }\r\n          this.trackAfter(\"discarded\", el);\r\n        },\r\n        onBeforeNodeDiscarded: (el) => {\r\n          if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {\r\n            return true;\r\n          }\r\n          if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, [\"append\", \"prepend\"]) && el.id) {\r\n            return false;\r\n          }\r\n          if (el.getAttribute && el.getAttribute(phxRemove)) {\r\n            pendingRemoves.push(el);\r\n            return false;\r\n          }\r\n          if (this.skipCIDSibling(el)) {\r\n            return false;\r\n          }\r\n          return true;\r\n        },\r\n        onElUpdated: (el) => {\r\n          if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\r\n            externalFormTriggered = el;\r\n          }\r\n          updates.push(el);\r\n        },\r\n        onBeforeElUpdated: (fromEl, toEl) => {\r\n          dom_default.cleanChildNodes(toEl, phxUpdate);\r\n          if (this.skipCIDSibling(toEl)) {\r\n            return false;\r\n          }\r\n          if (dom_default.isPhxSticky(fromEl)) {\r\n            return false;\r\n          }\r\n          if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {\r\n            this.trackBefore(\"updated\", fromEl, toEl);\r\n            dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });\r\n            updates.push(fromEl);\r\n            dom_default.applyStickyOperations(fromEl);\r\n            return false;\r\n          }\r\n          if (fromEl.type === \"number\" && (fromEl.validity && fromEl.validity.badInput)) {\r\n            return false;\r\n          }\r\n          if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {\r\n            if (dom_default.isUploadInput(fromEl)) {\r\n              this.trackBefore(\"updated\", fromEl, toEl);\r\n              updates.push(fromEl);\r\n            }\r\n            dom_default.applyStickyOperations(fromEl);\r\n            return false;\r\n          }\r\n          if (dom_default.isPhxChild(toEl)) {\r\n            let prevSession = fromEl.getAttribute(PHX_SESSION);\r\n            dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });\r\n            if (prevSession !== \"\") {\r\n              fromEl.setAttribute(PHX_SESSION, prevSession);\r\n            }\r\n            fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\r\n            dom_default.applyStickyOperations(fromEl);\r\n            return false;\r\n          }\r\n          dom_default.copyPrivates(toEl, fromEl);\r\n          dom_default.discardError(targetContainer, toEl, phxFeedbackFor);\r\n          let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);\r\n          if (isFocusedFormEl && fromEl.type !== \"hidden\") {\r\n            this.trackBefore(\"updated\", fromEl, toEl);\r\n            dom_default.mergeFocusedInput(fromEl, toEl);\r\n            dom_default.syncAttrsToProps(fromEl);\r\n            updates.push(fromEl);\r\n            dom_default.applyStickyOperations(fromEl);\r\n            return false;\r\n          } else {\r\n            if (dom_default.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\r\n              appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));\r\n            }\r\n            dom_default.syncAttrsToProps(toEl);\r\n            dom_default.applyStickyOperations(toEl);\r\n            this.trackBefore(\"updated\", fromEl, toEl);\r\n            return true;\r\n          }\r\n        }\r\n      });\r\n    });\r\n    if (liveSocket.isDebugEnabled()) {\r\n      detectDuplicateIds();\r\n    }\r\n    if (appendPrependUpdates.length > 0) {\r\n      liveSocket.time(\"post-morph append/prepend restoration\", () => {\r\n        appendPrependUpdates.forEach((update) => update.perform());\r\n      });\r\n    }\r\n    liveSocket.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));\r\n    dom_default.dispatchEvent(document, \"phx:update\");\r\n    added.forEach((el) => this.trackAfter(\"added\", el));\r\n    updates.forEach((el) => this.trackAfter(\"updated\", el));\r\n    if (pendingRemoves.length > 0) {\r\n      liveSocket.transitionRemoves(pendingRemoves);\r\n      liveSocket.requestDOMUpdate(() => {\r\n        pendingRemoves.forEach((el) => {\r\n          let child = dom_default.firstPhxChild(el);\r\n          if (child) {\r\n            liveSocket.destroyViewByEl(child);\r\n          }\r\n          el.remove();\r\n        });\r\n        this.trackAfter(\"transitionsDiscarded\", pendingRemoves);\r\n      });\r\n    }\r\n    if (externalFormTriggered) {\r\n      liveSocket.unload();\r\n      externalFormTriggered.submit();\r\n    }\r\n    return true;\r\n  }\r\n  isCIDPatch() {\r\n    return this.cidPatch;\r\n  }\r\n  skipCIDSibling(el) {\r\n    return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;\r\n  }\r\n  targetCIDContainer(html) {\r\n    if (!this.isCIDPatch()) {\r\n      return;\r\n    }\r\n    let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);\r\n    if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {\r\n      return first;\r\n    } else {\r\n      return first && first.parentNode;\r\n    }\r\n  }\r\n  buildDiffHTML(container, html, phxUpdate, targetContainer) {\r\n    let isCIDPatch = this.isCIDPatch();\r\n    let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();\r\n    if (!isCIDPatch || isCIDWithSingleRoot) {\r\n      return html;\r\n    } else {\r\n      let diffContainer = null;\r\n      let template = document.createElement(\"template\");\r\n      diffContainer = dom_default.cloneNode(targetContainer);\r\n      let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);\r\n      template.innerHTML = html;\r\n      rest.forEach((el) => el.remove());\r\n      Array.from(diffContainer.childNodes).forEach((child) => {\r\n        if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {\r\n          child.setAttribute(PHX_SKIP, \"\");\r\n          child.innerHTML = \"\";\r\n        }\r\n      });\r\n      Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));\r\n      firstComponent.remove();\r\n      return diffContainer.outerHTML;\r\n    }\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/rendered.js\r\nvar Rendered = class {\r\n  static extract(diff) {\r\n    let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;\r\n    delete diff[REPLY];\r\n    delete diff[EVENTS];\r\n    delete diff[TITLE];\r\n    return { diff, title, reply: reply || null, events: events || [] };\r\n  }\r\n  constructor(viewId, rendered) {\r\n    this.viewId = viewId;\r\n    this.rendered = {};\r\n    this.mergeDiff(rendered);\r\n  }\r\n  parentViewId() {\r\n    return this.viewId;\r\n  }\r\n  toString(onlyCids) {\r\n    return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);\r\n  }\r\n  recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {\r\n    onlyCids = onlyCids ? new Set(onlyCids) : null;\r\n    let output = { buffer: \"\", components, onlyCids };\r\n    this.toOutputBuffer(rendered, null, output);\r\n    return output.buffer;\r\n  }\r\n  componentCIDs(diff) {\r\n    return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));\r\n  }\r\n  isComponentOnlyDiff(diff) {\r\n    if (!diff[COMPONENTS]) {\r\n      return false;\r\n    }\r\n    return Object.keys(diff).length === 1;\r\n  }\r\n  getComponent(diff, cid) {\r\n    return diff[COMPONENTS][cid];\r\n  }\r\n  mergeDiff(diff) {\r\n    let newc = diff[COMPONENTS];\r\n    let cache = {};\r\n    delete diff[COMPONENTS];\r\n    this.rendered = this.mutableMerge(this.rendered, diff);\r\n    this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\r\n    if (newc) {\r\n      let oldc = this.rendered[COMPONENTS];\r\n      for (let cid in newc) {\r\n        newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\r\n      }\r\n      for (let cid in newc) {\r\n        oldc[cid] = newc[cid];\r\n      }\r\n      diff[COMPONENTS] = newc;\r\n    }\r\n  }\r\n  cachedFindComponent(cid, cdiff, oldc, newc, cache) {\r\n    if (cache[cid]) {\r\n      return cache[cid];\r\n    } else {\r\n      let ndiff, stat, scid = cdiff[STATIC];\r\n      if (isCid(scid)) {\r\n        let tdiff;\r\n        if (scid > 0) {\r\n          tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\r\n        } else {\r\n          tdiff = oldc[-scid];\r\n        }\r\n        stat = tdiff[STATIC];\r\n        ndiff = this.cloneMerge(tdiff, cdiff);\r\n        ndiff[STATIC] = stat;\r\n      } else {\r\n        ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);\r\n      }\r\n      cache[cid] = ndiff;\r\n      return ndiff;\r\n    }\r\n  }\r\n  mutableMerge(target, source) {\r\n    if (source[STATIC] !== void 0) {\r\n      return source;\r\n    } else {\r\n      this.doMutableMerge(target, source);\r\n      return target;\r\n    }\r\n  }\r\n  doMutableMerge(target, source) {\r\n    for (let key in source) {\r\n      let val = source[key];\r\n      let targetVal = target[key];\r\n      if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\r\n        this.doMutableMerge(targetVal, val);\r\n      } else {\r\n        target[key] = val;\r\n      }\r\n    }\r\n  }\r\n  cloneMerge(target, source) {\r\n    let merged = { ...target, ...source };\r\n    for (let key in merged) {\r\n      let val = source[key];\r\n      let targetVal = target[key];\r\n      if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\r\n        merged[key] = this.cloneMerge(targetVal, val);\r\n      }\r\n    }\r\n    return merged;\r\n  }\r\n  componentToString(cid) {\r\n    return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);\r\n  }\r\n  pruneCIDs(cids) {\r\n    cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);\r\n  }\r\n  get() {\r\n    return this.rendered;\r\n  }\r\n  isNewFingerprint(diff = {}) {\r\n    return !!diff[STATIC];\r\n  }\r\n  templateStatic(part, templates) {\r\n    if (typeof part === \"number\") {\r\n      return templates[part];\r\n    } else {\r\n      return part;\r\n    }\r\n  }\r\n  toOutputBuffer(rendered, templates, output) {\r\n    if (rendered[DYNAMICS]) {\r\n      return this.comprehensionToBuffer(rendered, templates, output);\r\n    }\r\n    let { [STATIC]: statics } = rendered;\r\n    statics = this.templateStatic(statics, templates);\r\n    output.buffer += statics[0];\r\n    for (let i = 1; i < statics.length; i++) {\r\n      this.dynamicToBuffer(rendered[i - 1], templates, output);\r\n      output.buffer += statics[i];\r\n    }\r\n  }\r\n  comprehensionToBuffer(rendered, templates, output) {\r\n    let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;\r\n    statics = this.templateStatic(statics, templates);\r\n    let compTemplates = templates || rendered[TEMPLATES];\r\n    for (let d = 0; d < dynamics.length; d++) {\r\n      let dynamic = dynamics[d];\r\n      output.buffer += statics[0];\r\n      for (let i = 1; i < statics.length; i++) {\r\n        this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);\r\n        output.buffer += statics[i];\r\n      }\r\n    }\r\n  }\r\n  dynamicToBuffer(rendered, templates, output) {\r\n    if (typeof rendered === \"number\") {\r\n      output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);\r\n    } else if (isObject(rendered)) {\r\n      this.toOutputBuffer(rendered, templates, output);\r\n    } else {\r\n      output.buffer += rendered;\r\n    }\r\n  }\r\n  recursiveCIDToString(components, cid, onlyCids) {\r\n    let component = components[cid] || logError(`no component for CID ${cid}`, components);\r\n    let template = document.createElement(\"template\");\r\n    template.innerHTML = this.recursiveToString(component, components, onlyCids);\r\n    let container = template.content;\r\n    let skip = onlyCids && !onlyCids.has(cid);\r\n    let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {\r\n      if (child.nodeType === Node.ELEMENT_NODE) {\r\n        if (child.getAttribute(PHX_COMPONENT)) {\r\n          return [hasNodes, true];\r\n        }\r\n        child.setAttribute(PHX_COMPONENT, cid);\r\n        if (!child.id) {\r\n          child.id = `${this.parentViewId()}-${cid}-${i}`;\r\n        }\r\n        if (skip) {\r\n          child.setAttribute(PHX_SKIP, \"\");\r\n          child.innerHTML = \"\";\r\n        }\r\n        return [true, hasComponents];\r\n      } else {\r\n        if (child.nodeValue.trim() !== \"\") {\r\n          logError(`only HTML element tags are allowed at the root of components.\r\n\r\ngot: \"${child.nodeValue.trim()}\"\r\n\r\nwithin:\r\n`, template.innerHTML.trim());\r\n          child.replaceWith(this.createSpan(child.nodeValue, cid));\r\n          return [true, hasComponents];\r\n        } else {\r\n          child.remove();\r\n          return [hasNodes, hasComponents];\r\n        }\r\n      }\r\n    }, [false, false]);\r\n    if (!hasChildNodes && !hasChildComponents) {\r\n      logError(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", template.innerHTML.trim());\r\n      return this.createSpan(\"\", cid).outerHTML;\r\n    } else if (!hasChildNodes && hasChildComponents) {\r\n      logError(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", template.innerHTML.trim());\r\n      return template.innerHTML;\r\n    } else {\r\n      return template.innerHTML;\r\n    }\r\n  }\r\n  createSpan(text, cid) {\r\n    let span = document.createElement(\"span\");\r\n    span.innerText = text;\r\n    span.setAttribute(PHX_COMPONENT, cid);\r\n    return span;\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/view_hook.js\r\nvar viewHookID = 1;\r\nvar ViewHook = class {\r\n  static makeID() {\r\n    return viewHookID++;\r\n  }\r\n  static elementID(el) {\r\n    return el.phxHookId;\r\n  }\r\n  constructor(view, el, callbacks) {\r\n    this.__view = view;\r\n    this.liveSocket = view.liveSocket;\r\n    this.__callbacks = callbacks;\r\n    this.__listeners = new Set();\r\n    this.__isDisconnected = false;\r\n    this.el = el;\r\n    this.el.phxHookId = this.constructor.makeID();\r\n    for (let key in this.__callbacks) {\r\n      this[key] = this.__callbacks[key];\r\n    }\r\n  }\r\n  __mounted() {\r\n    this.mounted && this.mounted();\r\n  }\r\n  __updated() {\r\n    this.updated && this.updated();\r\n  }\r\n  __beforeUpdate() {\r\n    this.beforeUpdate && this.beforeUpdate();\r\n  }\r\n  __destroyed() {\r\n    this.destroyed && this.destroyed();\r\n  }\r\n  __reconnected() {\r\n    if (this.__isDisconnected) {\r\n      this.__isDisconnected = false;\r\n      this.reconnected && this.reconnected();\r\n    }\r\n  }\r\n  __disconnected() {\r\n    this.__isDisconnected = true;\r\n    this.disconnected && this.disconnected();\r\n  }\r\n  pushEvent(event, payload = {}, onReply = function() {\r\n  }) {\r\n    return this.__view.pushHookEvent(null, event, payload, onReply);\r\n  }\r\n  pushEventTo(phxTarget, event, payload = {}, onReply = function() {\r\n  }) {\r\n    return this.__view.withinTargets(phxTarget, (view, targetCtx) => {\r\n      return view.pushHookEvent(targetCtx, event, payload, onReply);\r\n    });\r\n  }\r\n  handleEvent(event, callback) {\r\n    let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);\r\n    window.addEventListener(`phx:${event}`, callbackRef);\r\n    this.__listeners.add(callbackRef);\r\n    return callbackRef;\r\n  }\r\n  removeHandleEvent(callbackRef) {\r\n    let event = callbackRef(null, true);\r\n    window.removeEventListener(`phx:${event}`, callbackRef);\r\n    this.__listeners.delete(callbackRef);\r\n  }\r\n  upload(name, files) {\r\n    return this.__view.dispatchUploads(name, files);\r\n  }\r\n  uploadTo(phxTarget, name, files) {\r\n    return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));\r\n  }\r\n  __cleanup__() {\r\n    this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/js.js\r\nvar focusStack = null;\r\nvar JS = {\r\n  exec(eventType, phxEvent, view, sourceEl, defaults) {\r\n    let [defaultKind, defaultArgs] = defaults || [null, {}];\r\n    let commands = phxEvent.charAt(0) === \"[\" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];\r\n    commands.forEach(([kind, args]) => {\r\n      if (kind === defaultKind && defaultArgs.data) {\r\n        args.data = Object.assign(args.data || {}, defaultArgs.data);\r\n      }\r\n      this.filterToEls(sourceEl, args).forEach((el) => {\r\n        this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);\r\n      });\r\n    });\r\n  },\r\n  isVisible(el) {\r\n    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);\r\n  },\r\n  exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail, bubbles }) {\r\n    detail = detail || {};\r\n    detail.dispatcher = sourceEl;\r\n    dom_default.dispatchEvent(el, event, { detail, bubbles });\r\n  },\r\n  exec_push(eventType, phxEvent, view, sourceEl, el, args) {\r\n    if (!view.isConnected()) {\r\n      return;\r\n    }\r\n    let { event, data, target, page_loading, loading, value, dispatcher } = args;\r\n    let pushOpts = { loading, value, target, page_loading: !!page_loading };\r\n    let targetSrc = eventType === \"change\" && dispatcher ? dispatcher : sourceEl;\r\n    let phxTarget = target || targetSrc.getAttribute(view.binding(\"target\")) || targetSrc;\r\n    view.withinTargets(phxTarget, (targetView, targetCtx) => {\r\n      if (eventType === \"change\") {\r\n        let { newCid, _target, callback } = args;\r\n        _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);\r\n        if (_target) {\r\n          pushOpts._target = _target;\r\n        }\r\n        targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);\r\n      } else if (eventType === \"submit\") {\r\n        targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);\r\n      } else {\r\n        targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);\r\n      }\r\n    });\r\n  },\r\n  exec_navigate(eventType, phxEvent, view, sourceEl, el, { href, replace }) {\r\n    view.liveSocket.historyRedirect(href, replace ? \"replace\" : \"push\");\r\n  },\r\n  exec_patch(eventType, phxEvent, view, sourceEl, el, { href, replace }) {\r\n    view.liveSocket.pushHistoryPatch(href, replace ? \"replace\" : \"push\", sourceEl);\r\n  },\r\n  exec_focus(eventType, phxEvent, view, sourceEl, el) {\r\n    window.requestAnimationFrame(() => aria_default.attemptFocus(el));\r\n  },\r\n  exec_focus_first(eventType, phxEvent, view, sourceEl, el) {\r\n    window.requestAnimationFrame(() => aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el));\r\n  },\r\n  exec_push_focus(eventType, phxEvent, view, sourceEl, el) {\r\n    window.requestAnimationFrame(() => focusStack = el || sourceEl);\r\n  },\r\n  exec_pop_focus(eventType, phxEvent, view, sourceEl, el) {\r\n    window.requestAnimationFrame(() => {\r\n      if (focusStack) {\r\n        focusStack.focus();\r\n      }\r\n      focusStack = null;\r\n    });\r\n  },\r\n  exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {\r\n    this.addOrRemoveClasses(el, names, [], transition, time, view);\r\n  },\r\n  exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {\r\n    this.addOrRemoveClasses(el, [], names, transition, time, view);\r\n  },\r\n  exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {\r\n    let [transition_start, running, transition_end] = transition;\r\n    let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);\r\n    let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));\r\n    view.transition(time, onStart, onDone);\r\n  },\r\n  exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {\r\n    this.toggle(eventType, view, el, display, ins, outs, time);\r\n  },\r\n  exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {\r\n    this.show(eventType, view, el, display, transition, time);\r\n  },\r\n  exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {\r\n    this.hide(eventType, view, el, display, transition, time);\r\n  },\r\n  exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {\r\n    this.setOrRemoveAttrs(el, [[attr, val]], []);\r\n  },\r\n  exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {\r\n    this.setOrRemoveAttrs(el, [], [attr]);\r\n  },\r\n  show(eventType, view, el, display, transition, time) {\r\n    if (!this.isVisible(el)) {\r\n      this.toggle(eventType, view, el, display, transition, null, time);\r\n    }\r\n  },\r\n  hide(eventType, view, el, display, transition, time) {\r\n    if (this.isVisible(el)) {\r\n      this.toggle(eventType, view, el, display, null, transition, time);\r\n    }\r\n  },\r\n  toggle(eventType, view, el, display, ins, outs, time) {\r\n    let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];\r\n    let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];\r\n    if (inClasses.length > 0 || outClasses.length > 0) {\r\n      if (this.isVisible(el)) {\r\n        let onStart = () => {\r\n          this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));\r\n          window.requestAnimationFrame(() => {\r\n            this.addOrRemoveClasses(el, outClasses, []);\r\n            window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));\r\n          });\r\n        };\r\n        el.dispatchEvent(new Event(\"phx:hide-start\"));\r\n        view.transition(time, onStart, () => {\r\n          this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));\r\n          dom_default.putSticky(el, \"toggle\", (currentEl) => currentEl.style.display = \"none\");\r\n          el.dispatchEvent(new Event(\"phx:hide-end\"));\r\n        });\r\n      } else {\r\n        if (eventType === \"remove\") {\r\n          return;\r\n        }\r\n        let onStart = () => {\r\n          this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));\r\n          dom_default.putSticky(el, \"toggle\", (currentEl) => currentEl.style.display = display || \"block\");\r\n          window.requestAnimationFrame(() => {\r\n            this.addOrRemoveClasses(el, inClasses, []);\r\n            window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));\r\n          });\r\n        };\r\n        el.dispatchEvent(new Event(\"phx:show-start\"));\r\n        view.transition(time, onStart, () => {\r\n          this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));\r\n          el.dispatchEvent(new Event(\"phx:show-end\"));\r\n        });\r\n      }\r\n    } else {\r\n      if (this.isVisible(el)) {\r\n        window.requestAnimationFrame(() => {\r\n          el.dispatchEvent(new Event(\"phx:hide-start\"));\r\n          dom_default.putSticky(el, \"toggle\", (currentEl) => currentEl.style.display = \"none\");\r\n          el.dispatchEvent(new Event(\"phx:hide-end\"));\r\n        });\r\n      } else {\r\n        window.requestAnimationFrame(() => {\r\n          el.dispatchEvent(new Event(\"phx:show-start\"));\r\n          dom_default.putSticky(el, \"toggle\", (currentEl) => currentEl.style.display = display || \"block\");\r\n          el.dispatchEvent(new Event(\"phx:show-end\"));\r\n        });\r\n      }\r\n    }\r\n  },\r\n  addOrRemoveClasses(el, adds, removes, transition, time, view) {\r\n    let [transition_run, transition_start, transition_end] = transition || [[], [], []];\r\n    if (transition_run.length > 0) {\r\n      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);\r\n      let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));\r\n      return view.transition(time, onStart, onDone);\r\n    }\r\n    window.requestAnimationFrame(() => {\r\n      let [prevAdds, prevRemoves] = dom_default.getSticky(el, \"classes\", [[], []]);\r\n      let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));\r\n      let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));\r\n      let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);\r\n      let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);\r\n      dom_default.putSticky(el, \"classes\", (currentEl) => {\r\n        currentEl.classList.remove(...newRemoves);\r\n        currentEl.classList.add(...newAdds);\r\n        return [newAdds, newRemoves];\r\n      });\r\n    });\r\n  },\r\n  setOrRemoveAttrs(el, sets, removes) {\r\n    let [prevSets, prevRemoves] = dom_default.getSticky(el, \"attrs\", [[], []]);\r\n    let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);\r\n    let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);\r\n    let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);\r\n    dom_default.putSticky(el, \"attrs\", (currentEl) => {\r\n      newRemoves.forEach((attr) => currentEl.removeAttribute(attr));\r\n      newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));\r\n      return [newSets, newRemoves];\r\n    });\r\n  },\r\n  hasAllClasses(el, classes) {\r\n    return classes.every((name) => el.classList.contains(name));\r\n  },\r\n  isToggledOut(el, outClasses) {\r\n    return !this.isVisible(el) || this.hasAllClasses(el, outClasses);\r\n  },\r\n  filterToEls(sourceEl, { to }) {\r\n    return to ? dom_default.all(document, to) : [sourceEl];\r\n  }\r\n};\r\nvar js_default = JS;\r\n\r\n// js/phoenix_live_view/view.js\r\nvar serializeForm = (form, meta, onlyNames = []) => {\r\n  let formData = new FormData(form);\r\n  let toRemove = [];\r\n  formData.forEach((val, key, _index) => {\r\n    if (val instanceof File) {\r\n      toRemove.push(key);\r\n    }\r\n  });\r\n  toRemove.forEach((key) => formData.delete(key));\r\n  let params = new URLSearchParams();\r\n  for (let [key, val] of formData.entries()) {\r\n    if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {\r\n      params.append(key, val);\r\n    }\r\n  }\r\n  for (let metaKey in meta) {\r\n    params.append(metaKey, meta[metaKey]);\r\n  }\r\n  return params.toString();\r\n};\r\nvar View = class {\r\n  constructor(el, liveSocket, parentView, flash, liveReferer) {\r\n    this.isDead = false;\r\n    this.liveSocket = liveSocket;\r\n    this.flash = flash;\r\n    this.parent = parentView;\r\n    this.root = parentView ? parentView.root : this;\r\n    this.el = el;\r\n    this.id = this.el.id;\r\n    this.ref = 0;\r\n    this.childJoins = 0;\r\n    this.loaderTimer = null;\r\n    this.pendingDiffs = [];\r\n    this.pruningCIDs = [];\r\n    this.redirect = false;\r\n    this.href = null;\r\n    this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\r\n    this.joinPending = true;\r\n    this.destroyed = false;\r\n    this.joinCallback = function(onDone) {\r\n      onDone && onDone();\r\n    };\r\n    this.stopCallback = function() {\r\n    };\r\n    this.pendingJoinOps = this.parent ? null : [];\r\n    this.viewHooks = {};\r\n    this.uploaders = {};\r\n    this.formSubmits = [];\r\n    this.children = this.parent ? null : {};\r\n    this.root.children[this.id] = {};\r\n    this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\r\n      return {\r\n        redirect: this.redirect ? this.href : void 0,\r\n        url: this.redirect ? void 0 : this.href || void 0,\r\n        params: this.connectParams(liveReferer),\r\n        session: this.getSession(),\r\n        static: this.getStatic(),\r\n        flash: this.flash\r\n      };\r\n    });\r\n  }\r\n  setHref(href) {\r\n    this.href = href;\r\n  }\r\n  setRedirect(href) {\r\n    this.redirect = true;\r\n    this.href = href;\r\n  }\r\n  isMain() {\r\n    return this.el.hasAttribute(PHX_MAIN);\r\n  }\r\n  connectParams(liveReferer) {\r\n    let params = this.liveSocket.params(this.el);\r\n    let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === \"string\");\r\n    if (manifest.length > 0) {\r\n      params[\"_track_static\"] = manifest;\r\n    }\r\n    params[\"_mounts\"] = this.joinCount;\r\n    params[\"_live_referer\"] = liveReferer;\r\n    return params;\r\n  }\r\n  isConnected() {\r\n    return this.channel.canPush();\r\n  }\r\n  getSession() {\r\n    return this.el.getAttribute(PHX_SESSION);\r\n  }\r\n  getStatic() {\r\n    let val = this.el.getAttribute(PHX_STATIC);\r\n    return val === \"\" ? null : val;\r\n  }\r\n  destroy(callback = function() {\r\n  }) {\r\n    this.destroyAllChildren();\r\n    this.destroyed = true;\r\n    delete this.root.children[this.id];\r\n    if (this.parent) {\r\n      delete this.root.children[this.parent.id][this.id];\r\n    }\r\n    clearTimeout(this.loaderTimer);\r\n    let onFinished = () => {\r\n      callback();\r\n      for (let id in this.viewHooks) {\r\n        this.destroyHook(this.viewHooks[id]);\r\n      }\r\n    };\r\n    dom_default.markPhxChildDestroyed(this.el);\r\n    this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\r\n    this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\r\n  }\r\n  setContainerClasses(...classes) {\r\n    this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\r\n    this.el.classList.add(...classes);\r\n  }\r\n  showLoader(timeout) {\r\n    clearTimeout(this.loaderTimer);\r\n    if (timeout) {\r\n      this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\r\n    } else {\r\n      for (let id in this.viewHooks) {\r\n        this.viewHooks[id].__disconnected();\r\n      }\r\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS);\r\n    }\r\n  }\r\n  execAll(binding) {\r\n    dom_default.all(this.el, `[${binding}]`, (el) => this.liveSocket.execJS(el, el.getAttribute(binding)));\r\n  }\r\n  hideLoader() {\r\n    clearTimeout(this.loaderTimer);\r\n    this.setContainerClasses(PHX_CONNECTED_CLASS);\r\n    this.execAll(this.binding(\"connected\"));\r\n  }\r\n  triggerReconnected() {\r\n    for (let id in this.viewHooks) {\r\n      this.viewHooks[id].__reconnected();\r\n    }\r\n  }\r\n  log(kind, msgCallback) {\r\n    this.liveSocket.log(this, kind, msgCallback);\r\n  }\r\n  transition(time, onStart, onDone = function() {\r\n  }) {\r\n    this.liveSocket.transition(time, onStart, onDone);\r\n  }\r\n  withinTargets(phxTarget, callback) {\r\n    if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {\r\n      return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));\r\n    }\r\n    if (isCid(phxTarget)) {\r\n      let targets = dom_default.findComponentNodeList(this.el, phxTarget);\r\n      if (targets.length === 0) {\r\n        logError(`no component found matching phx-target of ${phxTarget}`);\r\n      } else {\r\n        callback(this, parseInt(phxTarget));\r\n      }\r\n    } else {\r\n      let targets = Array.from(document.querySelectorAll(phxTarget));\r\n      if (targets.length === 0) {\r\n        logError(`nothing found matching the phx-target selector \"${phxTarget}\"`);\r\n      }\r\n      targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));\r\n    }\r\n  }\r\n  applyDiff(type, rawDiff, callback) {\r\n    this.log(type, () => [\"\", clone(rawDiff)]);\r\n    let { diff, reply, events, title } = Rendered.extract(rawDiff);\r\n    callback({ diff, reply, events });\r\n    if (title) {\r\n      window.requestAnimationFrame(() => dom_default.putTitle(title));\r\n    }\r\n  }\r\n  onJoin(resp) {\r\n    let { rendered, container } = resp;\r\n    if (container) {\r\n      let [tag, attrs] = container;\r\n      this.el = dom_default.replaceRootContainer(this.el, tag, attrs);\r\n    }\r\n    this.childJoins = 0;\r\n    this.joinPending = true;\r\n    this.flash = null;\r\n    browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);\r\n    this.applyDiff(\"mount\", rendered, ({ diff, events }) => {\r\n      this.rendered = new Rendered(this.id, diff);\r\n      let html = this.renderContainer(null, \"join\");\r\n      this.dropPendingRefs();\r\n      let forms = this.formsForRecovery(html);\r\n      this.joinCount++;\r\n      if (forms.length > 0) {\r\n        forms.forEach(([form, newForm, newCid], i) => {\r\n          this.pushFormRecovery(form, newCid, (resp2) => {\r\n            if (i === forms.length - 1) {\r\n              this.onJoinComplete(resp2, html, events);\r\n            }\r\n          });\r\n        });\r\n      } else {\r\n        this.onJoinComplete(resp, html, events);\r\n      }\r\n    });\r\n  }\r\n  dropPendingRefs() {\r\n    dom_default.all(document, `[${PHX_REF_SRC}=\"${this.id}\"][${PHX_REF}]`, (el) => {\r\n      el.removeAttribute(PHX_REF);\r\n      el.removeAttribute(PHX_REF_SRC);\r\n    });\r\n  }\r\n  onJoinComplete({ live_patch }, html, events) {\r\n    if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\r\n      return this.applyJoinPatch(live_patch, html, events);\r\n    }\r\n    let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {\r\n      let fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\r\n      let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\r\n      if (phxStatic) {\r\n        toEl.setAttribute(PHX_STATIC, phxStatic);\r\n      }\r\n      return this.joinChild(toEl);\r\n    });\r\n    if (newChildren.length === 0) {\r\n      if (this.parent) {\r\n        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\r\n        this.parent.ackJoin(this);\r\n      } else {\r\n        this.onAllChildJoinsComplete();\r\n        this.applyJoinPatch(live_patch, html, events);\r\n      }\r\n    } else {\r\n      this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\r\n    }\r\n  }\r\n  attachTrueDocEl() {\r\n    this.el = dom_default.byId(this.id);\r\n    this.el.setAttribute(PHX_ROOT_ID, this.root.id);\r\n  }\r\n  execNewMounted() {\r\n    dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {\r\n      this.maybeAddNewHook(hookEl);\r\n    });\r\n    dom_default.all(this.el, `[${this.binding(PHX_MOUNTED)}]`, (el) => this.maybeMounted(el));\r\n  }\r\n  applyJoinPatch(live_patch, html, events) {\r\n    this.attachTrueDocEl();\r\n    let patch = new DOMPatch(this, this.el, this.id, html, null);\r\n    patch.markPrunableContentForRemoval();\r\n    this.performPatch(patch, false);\r\n    this.joinNewChildren();\r\n    this.execNewMounted();\r\n    this.joinPending = false;\r\n    this.liveSocket.dispatchEvents(events);\r\n    this.applyPendingUpdates();\r\n    if (live_patch) {\r\n      let { kind, to } = live_patch;\r\n      this.liveSocket.historyPatch(to, kind);\r\n    }\r\n    this.hideLoader();\r\n    if (this.joinCount > 1) {\r\n      this.triggerReconnected();\r\n    }\r\n    this.stopCallback();\r\n  }\r\n  triggerBeforeUpdateHook(fromEl, toEl) {\r\n    this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\r\n    let hook = this.getHook(fromEl);\r\n    let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));\r\n    if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\r\n      hook.__beforeUpdate();\r\n      return hook;\r\n    }\r\n  }\r\n  maybeMounted(el) {\r\n    let phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));\r\n    let hasBeenInvoked = phxMounted && dom_default.private(el, \"mounted\");\r\n    if (phxMounted && !hasBeenInvoked) {\r\n      this.liveSocket.execJS(el, phxMounted);\r\n      dom_default.putPrivate(el, \"mounted\", true);\r\n    }\r\n  }\r\n  maybeAddNewHook(el, force) {\r\n    let newHook = this.addHook(el);\r\n    if (newHook) {\r\n      newHook.__mounted();\r\n    }\r\n  }\r\n  performPatch(patch, pruneCids) {\r\n    let removedEls = [];\r\n    let phxChildrenAdded = false;\r\n    let updatedHookIds = new Set();\r\n    patch.after(\"added\", (el) => {\r\n      this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\r\n      this.maybeAddNewHook(el);\r\n      if (el.getAttribute) {\r\n        this.maybeMounted(el);\r\n      }\r\n    });\r\n    patch.after(\"phxChildAdded\", (el) => {\r\n      if (dom_default.isPhxSticky(el)) {\r\n        this.liveSocket.joinRootViews();\r\n      } else {\r\n        phxChildrenAdded = true;\r\n      }\r\n    });\r\n    patch.before(\"updated\", (fromEl, toEl) => {\r\n      let hook = this.triggerBeforeUpdateHook(fromEl, toEl);\r\n      if (hook) {\r\n        updatedHookIds.add(fromEl.id);\r\n      }\r\n    });\r\n    patch.after(\"updated\", (el) => {\r\n      if (updatedHookIds.has(el.id)) {\r\n        this.getHook(el).__updated();\r\n      }\r\n    });\r\n    patch.after(\"discarded\", (el) => {\r\n      if (el.nodeType === Node.ELEMENT_NODE) {\r\n        removedEls.push(el);\r\n      }\r\n    });\r\n    patch.after(\"transitionsDiscarded\", (els) => this.afterElementsRemoved(els, pruneCids));\r\n    patch.perform();\r\n    this.afterElementsRemoved(removedEls, pruneCids);\r\n    return phxChildrenAdded;\r\n  }\r\n  afterElementsRemoved(elements, pruneCids) {\r\n    let destroyedCIDs = [];\r\n    elements.forEach((parent) => {\r\n      let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);\r\n      let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);\r\n      components.concat(parent).forEach((el) => {\r\n        let cid = this.componentID(el);\r\n        if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {\r\n          destroyedCIDs.push(cid);\r\n        }\r\n      });\r\n      hooks.concat(parent).forEach((hookEl) => {\r\n        let hook = this.getHook(hookEl);\r\n        hook && this.destroyHook(hook);\r\n      });\r\n    });\r\n    if (pruneCids) {\r\n      this.maybePushComponentsDestroyed(destroyedCIDs);\r\n    }\r\n  }\r\n  joinNewChildren() {\r\n    dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));\r\n  }\r\n  getChildById(id) {\r\n    return this.root.children[this.id][id];\r\n  }\r\n  getDescendentByEl(el) {\r\n    if (el.id === this.id) {\r\n      return this;\r\n    } else {\r\n      return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];\r\n    }\r\n  }\r\n  destroyDescendent(id) {\r\n    for (let parentId in this.root.children) {\r\n      for (let childId in this.root.children[parentId]) {\r\n        if (childId === id) {\r\n          return this.root.children[parentId][childId].destroy();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  joinChild(el) {\r\n    let child = this.getChildById(el.id);\r\n    if (!child) {\r\n      let view = new View(el, this.liveSocket, this);\r\n      this.root.children[this.id][view.id] = view;\r\n      view.join();\r\n      this.childJoins++;\r\n      return true;\r\n    }\r\n  }\r\n  isJoinPending() {\r\n    return this.joinPending;\r\n  }\r\n  ackJoin(_child) {\r\n    this.childJoins--;\r\n    if (this.childJoins === 0) {\r\n      if (this.parent) {\r\n        this.parent.ackJoin(this);\r\n      } else {\r\n        this.onAllChildJoinsComplete();\r\n      }\r\n    }\r\n  }\r\n  onAllChildJoinsComplete() {\r\n    this.joinCallback(() => {\r\n      this.pendingJoinOps.forEach(([view, op]) => {\r\n        if (!view.isDestroyed()) {\r\n          op();\r\n        }\r\n      });\r\n      this.pendingJoinOps = [];\r\n    });\r\n  }\r\n  update(diff, events) {\r\n    if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {\r\n      return this.pendingDiffs.push({ diff, events });\r\n    }\r\n    this.rendered.mergeDiff(diff);\r\n    let phxChildrenAdded = false;\r\n    if (this.rendered.isComponentOnlyDiff(diff)) {\r\n      this.liveSocket.time(\"component patch complete\", () => {\r\n        let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));\r\n        parentCids.forEach((parentCID) => {\r\n          if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {\r\n            phxChildrenAdded = true;\r\n          }\r\n        });\r\n      });\r\n    } else if (!isEmpty(diff)) {\r\n      this.liveSocket.time(\"full patch complete\", () => {\r\n        let html = this.renderContainer(diff, \"update\");\r\n        let patch = new DOMPatch(this, this.el, this.id, html, null);\r\n        phxChildrenAdded = this.performPatch(patch, true);\r\n      });\r\n    }\r\n    this.liveSocket.dispatchEvents(events);\r\n    if (phxChildrenAdded) {\r\n      this.joinNewChildren();\r\n    }\r\n  }\r\n  renderContainer(diff, kind) {\r\n    return this.liveSocket.time(`toString diff (${kind})`, () => {\r\n      let tag = this.el.tagName;\r\n      let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;\r\n      let html = this.rendered.toString(cids);\r\n      return `<${tag}>${html}</${tag}>`;\r\n    });\r\n  }\r\n  componentPatch(diff, cid) {\r\n    if (isEmpty(diff))\r\n      return false;\r\n    let html = this.rendered.componentToString(cid);\r\n    let patch = new DOMPatch(this, this.el, this.id, html, cid);\r\n    let childrenAdded = this.performPatch(patch, true);\r\n    return childrenAdded;\r\n  }\r\n  getHook(el) {\r\n    return this.viewHooks[ViewHook.elementID(el)];\r\n  }\r\n  addHook(el) {\r\n    if (ViewHook.elementID(el) || !el.getAttribute) {\r\n      return;\r\n    }\r\n    let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));\r\n    if (hookName && !this.ownsElement(el)) {\r\n      return;\r\n    }\r\n    let callbacks = this.liveSocket.getHookCallbacks(hookName);\r\n    if (callbacks) {\r\n      if (!el.id) {\r\n        logError(`no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`, el);\r\n      }\r\n      let hook = new ViewHook(this, el, callbacks);\r\n      this.viewHooks[ViewHook.elementID(hook.el)] = hook;\r\n      return hook;\r\n    } else if (hookName !== null) {\r\n      logError(`unknown hook found for \"${hookName}\"`, el);\r\n    }\r\n  }\r\n  destroyHook(hook) {\r\n    hook.__destroyed();\r\n    hook.__cleanup__();\r\n    delete this.viewHooks[ViewHook.elementID(hook.el)];\r\n  }\r\n  applyPendingUpdates() {\r\n    this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));\r\n    this.pendingDiffs = [];\r\n    this.eachChild((child) => child.applyPendingUpdates());\r\n  }\r\n  eachChild(callback) {\r\n    let children = this.root.children[this.id] || {};\r\n    for (let id in children) {\r\n      callback(this.getChildById(id));\r\n    }\r\n  }\r\n  onChannel(event, cb) {\r\n    this.liveSocket.onChannel(this.channel, event, (resp) => {\r\n      if (this.isJoinPending()) {\r\n        this.root.pendingJoinOps.push([this, () => cb(resp)]);\r\n      } else {\r\n        this.liveSocket.requestDOMUpdate(() => cb(resp));\r\n      }\r\n    });\r\n  }\r\n  bindChannel() {\r\n    this.liveSocket.onChannel(this.channel, \"diff\", (rawDiff) => {\r\n      this.liveSocket.requestDOMUpdate(() => {\r\n        this.applyDiff(\"update\", rawDiff, ({ diff, events }) => this.update(diff, events));\r\n      });\r\n    });\r\n    this.onChannel(\"redirect\", ({ to, flash }) => this.onRedirect({ to, flash }));\r\n    this.onChannel(\"live_patch\", (redir) => this.onLivePatch(redir));\r\n    this.onChannel(\"live_redirect\", (redir) => this.onLiveRedirect(redir));\r\n    this.channel.onError((reason) => this.onError(reason));\r\n    this.channel.onClose((reason) => this.onClose(reason));\r\n  }\r\n  destroyAllChildren() {\r\n    this.eachChild((child) => child.destroy());\r\n  }\r\n  onLiveRedirect(redir) {\r\n    let { to, kind, flash } = redir;\r\n    let url = this.expandURL(to);\r\n    this.liveSocket.historyRedirect(url, kind, flash);\r\n  }\r\n  onLivePatch(redir) {\r\n    let { to, kind } = redir;\r\n    this.href = this.expandURL(to);\r\n    this.liveSocket.historyPatch(to, kind);\r\n  }\r\n  expandURL(to) {\r\n    return to.startsWith(\"/\") ? `${window.location.protocol}//${window.location.host}${to}` : to;\r\n  }\r\n  onRedirect({ to, flash }) {\r\n    this.liveSocket.redirect(to, flash);\r\n  }\r\n  isDestroyed() {\r\n    return this.destroyed;\r\n  }\r\n  joinDead() {\r\n    this.isDead = true;\r\n  }\r\n  join(callback) {\r\n    this.showLoader(this.liveSocket.loaderTimeout);\r\n    this.bindChannel();\r\n    if (this.isMain()) {\r\n      this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: \"initial\" });\r\n    }\r\n    this.joinCallback = (onDone) => {\r\n      onDone = onDone || function() {\r\n      };\r\n      callback ? callback(this.joinCount, onDone) : onDone();\r\n    };\r\n    this.liveSocket.wrapPush(this, { timeout: false }, () => {\r\n      return this.channel.join().receive(\"ok\", (data) => {\r\n        if (!this.isDestroyed()) {\r\n          this.liveSocket.requestDOMUpdate(() => this.onJoin(data));\r\n        }\r\n      }).receive(\"error\", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive(\"timeout\", () => !this.isDestroyed() && this.onJoinError({ reason: \"timeout\" }));\r\n    });\r\n  }\r\n  onJoinError(resp) {\r\n    if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\r\n      this.log(\"error\", () => [\"unauthorized live_redirect. Falling back to page request\", resp]);\r\n      return this.onRedirect({ to: this.href });\r\n    }\r\n    if (resp.redirect || resp.live_redirect) {\r\n      this.joinPending = false;\r\n      this.channel.leave();\r\n    }\r\n    if (resp.redirect) {\r\n      return this.onRedirect(resp.redirect);\r\n    }\r\n    if (resp.live_redirect) {\r\n      return this.onLiveRedirect(resp.live_redirect);\r\n    }\r\n    this.log(\"error\", () => [\"unable to join\", resp]);\r\n    if (this.liveSocket.isConnected()) {\r\n      this.liveSocket.reloadWithJitter(this);\r\n    }\r\n  }\r\n  onClose(reason) {\r\n    if (this.isDestroyed()) {\r\n      return;\r\n    }\r\n    if (this.liveSocket.hasPendingLink() && reason !== \"leave\") {\r\n      return this.liveSocket.reloadWithJitter(this);\r\n    }\r\n    this.destroyAllChildren();\r\n    this.liveSocket.dropActiveElement(this);\r\n    if (document.activeElement) {\r\n      document.activeElement.blur();\r\n    }\r\n    if (this.liveSocket.isUnloaded()) {\r\n      this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\r\n    }\r\n  }\r\n  onError(reason) {\r\n    this.onClose(reason);\r\n    if (this.liveSocket.isConnected()) {\r\n      this.log(\"error\", () => [\"view crashed\", reason]);\r\n    }\r\n    if (!this.liveSocket.isUnloaded()) {\r\n      this.displayError();\r\n    }\r\n  }\r\n  displayError() {\r\n    if (this.isMain()) {\r\n      dom_default.dispatchEvent(window, \"phx:page-loading-start\", { detail: { to: this.href, kind: \"error\" } });\r\n    }\r\n    this.showLoader();\r\n    this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\r\n    this.execAll(this.binding(\"disconnected\"));\r\n  }\r\n  pushWithReply(refGenerator, event, payload, onReply = function() {\r\n  }) {\r\n    if (!this.isConnected()) {\r\n      return;\r\n    }\r\n    let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];\r\n    let onLoadingDone = function() {\r\n    };\r\n    if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {\r\n      onLoadingDone = this.liveSocket.withPageLoading({ kind: \"element\", target: el });\r\n    }\r\n    if (typeof payload.cid !== \"number\") {\r\n      delete payload.cid;\r\n    }\r\n    return this.liveSocket.wrapPush(this, { timeout: true }, () => {\r\n      return this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", (resp) => {\r\n        let finish = (hookReply) => {\r\n          if (resp.redirect) {\r\n            this.onRedirect(resp.redirect);\r\n          }\r\n          if (resp.live_patch) {\r\n            this.onLivePatch(resp.live_patch);\r\n          }\r\n          if (resp.live_redirect) {\r\n            this.onLiveRedirect(resp.live_redirect);\r\n          }\r\n          if (ref !== null) {\r\n            this.undoRefs(ref);\r\n          }\r\n          onLoadingDone();\r\n          onReply(resp, hookReply);\r\n        };\r\n        if (resp.diff) {\r\n          this.liveSocket.requestDOMUpdate(() => {\r\n            this.applyDiff(\"update\", resp.diff, ({ diff, reply, events }) => {\r\n              this.update(diff, events);\r\n              finish(reply);\r\n            });\r\n          });\r\n        } else {\r\n          finish(null);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  undoRefs(ref) {\r\n    if (!this.isConnected()) {\r\n      return;\r\n    }\r\n    dom_default.all(document, `[${PHX_REF_SRC}=\"${this.id}\"][${PHX_REF}=\"${ref}\"]`, (el) => {\r\n      let disabledVal = el.getAttribute(PHX_DISABLED);\r\n      el.removeAttribute(PHX_REF);\r\n      el.removeAttribute(PHX_REF_SRC);\r\n      if (el.getAttribute(PHX_READONLY) !== null) {\r\n        el.readOnly = false;\r\n        el.removeAttribute(PHX_READONLY);\r\n      }\r\n      if (disabledVal !== null) {\r\n        el.disabled = disabledVal === \"true\" ? true : false;\r\n        el.removeAttribute(PHX_DISABLED);\r\n      }\r\n      PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));\r\n      let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);\r\n      if (disableRestore !== null) {\r\n        el.innerText = disableRestore;\r\n        el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\r\n      }\r\n      let toEl = dom_default.private(el, PHX_REF);\r\n      if (toEl) {\r\n        let hook = this.triggerBeforeUpdateHook(el, toEl);\r\n        DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());\r\n        if (hook) {\r\n          hook.__updated();\r\n        }\r\n        dom_default.deletePrivate(el, PHX_REF);\r\n      }\r\n    });\r\n  }\r\n  putRef(elements, event, opts = {}) {\r\n    let newRef = this.ref++;\r\n    let disableWith = this.binding(PHX_DISABLE_WITH);\r\n    if (opts.loading) {\r\n      elements = elements.concat(dom_default.all(document, opts.loading));\r\n    }\r\n    elements.forEach((el) => {\r\n      el.classList.add(`phx-${event}-loading`);\r\n      el.setAttribute(PHX_REF, newRef);\r\n      el.setAttribute(PHX_REF_SRC, this.el.id);\r\n      let disableText = el.getAttribute(disableWith);\r\n      if (disableText !== null) {\r\n        if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\r\n          el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\r\n        }\r\n        if (disableText !== \"\") {\r\n          el.innerText = disableText;\r\n        }\r\n        el.setAttribute(\"disabled\", \"\");\r\n      }\r\n    });\r\n    return [newRef, elements, opts];\r\n  }\r\n  componentID(el) {\r\n    let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\r\n    return cid ? parseInt(cid) : null;\r\n  }\r\n  targetComponentID(target, targetCtx, opts = {}) {\r\n    if (isCid(targetCtx)) {\r\n      return targetCtx;\r\n    }\r\n    let cidOrSelector = target.getAttribute(this.binding(\"target\"));\r\n    if (isCid(cidOrSelector)) {\r\n      return parseInt(cidOrSelector);\r\n    } else if (targetCtx && (cidOrSelector !== null || opts.target)) {\r\n      return this.closestComponentID(targetCtx);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  closestComponentID(targetCtx) {\r\n    if (isCid(targetCtx)) {\r\n      return targetCtx;\r\n    } else if (targetCtx) {\r\n      return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  pushHookEvent(targetCtx, event, payload, onReply) {\r\n    if (!this.isConnected()) {\r\n      this.log(\"hook\", () => [\"unable to push hook event. LiveView not connected\", event, payload]);\r\n      return false;\r\n    }\r\n    let [ref, els, opts] = this.putRef([], \"hook\");\r\n    this.pushWithReply(() => [ref, els, opts], \"event\", {\r\n      type: \"hook\",\r\n      event,\r\n      value: payload,\r\n      cid: this.closestComponentID(targetCtx)\r\n    }, (resp, reply) => onReply(reply, ref));\r\n    return ref;\r\n  }\r\n  extractMeta(el, meta, value) {\r\n    let prefix = this.binding(\"value-\");\r\n    for (let i = 0; i < el.attributes.length; i++) {\r\n      if (!meta) {\r\n        meta = {};\r\n      }\r\n      let name = el.attributes[i].name;\r\n      if (name.startsWith(prefix)) {\r\n        meta[name.replace(prefix, \"\")] = el.getAttribute(name);\r\n      }\r\n    }\r\n    if (el.value !== void 0) {\r\n      if (!meta) {\r\n        meta = {};\r\n      }\r\n      meta.value = el.value;\r\n      if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\r\n        delete meta.value;\r\n      }\r\n    }\r\n    if (value) {\r\n      if (!meta) {\r\n        meta = {};\r\n      }\r\n      for (let key in value) {\r\n        meta[key] = value[key];\r\n      }\r\n    }\r\n    return meta;\r\n  }\r\n  pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {\r\n    this.pushWithReply(() => this.putRef([el], type, opts), \"event\", {\r\n      type,\r\n      event: phxEvent,\r\n      value: this.extractMeta(el, meta, opts.value),\r\n      cid: this.targetComponentID(el, targetCtx, opts)\r\n    });\r\n  }\r\n  pushFileProgress(fileEl, entryRef, progress, onReply = function() {\r\n  }) {\r\n    this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\r\n      view.pushWithReply(null, \"progress\", {\r\n        event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\r\n        ref: fileEl.getAttribute(PHX_UPLOAD_REF),\r\n        entry_ref: entryRef,\r\n        progress,\r\n        cid: view.targetComponentID(fileEl.form, targetCtx)\r\n      }, onReply);\r\n    });\r\n  }\r\n  pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {\r\n    let uploads;\r\n    let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);\r\n    let refGenerator = () => this.putRef([inputEl, inputEl.form], \"change\", opts);\r\n    let formData;\r\n    if (inputEl.getAttribute(this.binding(\"change\"))) {\r\n      formData = serializeForm(inputEl.form, { _target: opts._target }, [inputEl.name]);\r\n    } else {\r\n      formData = serializeForm(inputEl.form, { _target: opts._target });\r\n    }\r\n    if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {\r\n      LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\r\n    }\r\n    uploads = LiveUploader.serializeUploads(inputEl);\r\n    let event = {\r\n      type: \"form\",\r\n      event: phxEvent,\r\n      value: formData,\r\n      uploads,\r\n      cid\r\n    };\r\n    this.pushWithReply(refGenerator, \"event\", event, (resp) => {\r\n      dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));\r\n      if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute(\"data-phx-auto-upload\") !== null) {\r\n        if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\r\n          let [ref, _els] = refGenerator();\r\n          this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {\r\n            callback && callback(resp);\r\n            this.triggerAwaitingSubmit(inputEl.form);\r\n          });\r\n        }\r\n      } else {\r\n        callback && callback(resp);\r\n      }\r\n    });\r\n  }\r\n  triggerAwaitingSubmit(formEl) {\r\n    let awaitingSubmit = this.getScheduledSubmit(formEl);\r\n    if (awaitingSubmit) {\r\n      let [_el, _ref, _opts, callback] = awaitingSubmit;\r\n      this.cancelSubmit(formEl);\r\n      callback();\r\n    }\r\n  }\r\n  getScheduledSubmit(formEl) {\r\n    return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));\r\n  }\r\n  scheduleSubmit(formEl, ref, opts, callback) {\r\n    if (this.getScheduledSubmit(formEl)) {\r\n      return true;\r\n    }\r\n    this.formSubmits.push([formEl, ref, opts, callback]);\r\n  }\r\n  cancelSubmit(formEl) {\r\n    this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {\r\n      if (el.isSameNode(formEl)) {\r\n        this.undoRefs(ref);\r\n        return false;\r\n      } else {\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  disableForm(formEl, opts = {}) {\r\n    let filterIgnored = (el) => {\r\n      let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);\r\n      return !(userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form));\r\n    };\r\n    let filterDisables = (el) => {\r\n      return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\r\n    };\r\n    let filterButton = (el) => el.tagName == \"BUTTON\";\r\n    let filterInput = (el) => [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\r\n    let formElements = Array.from(formEl.elements);\r\n    let disables = formElements.filter(filterDisables);\r\n    let buttons = formElements.filter(filterButton).filter(filterIgnored);\r\n    let inputs = formElements.filter(filterInput).filter(filterIgnored);\r\n    buttons.forEach((button) => {\r\n      button.setAttribute(PHX_DISABLED, button.disabled);\r\n      button.disabled = true;\r\n    });\r\n    inputs.forEach((input) => {\r\n      input.setAttribute(PHX_READONLY, input.readOnly);\r\n      input.readOnly = true;\r\n      if (input.files) {\r\n        input.setAttribute(PHX_DISABLED, input.disabled);\r\n        input.disabled = true;\r\n      }\r\n    });\r\n    formEl.setAttribute(this.binding(PHX_PAGE_LOADING), \"\");\r\n    return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), \"submit\", opts);\r\n  }\r\n  pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {\r\n    let refGenerator = () => this.disableForm(formEl, opts);\r\n    let cid = this.targetComponentID(formEl, targetCtx);\r\n    if (LiveUploader.hasUploadsInProgress(formEl)) {\r\n      let [ref, _els] = refGenerator();\r\n      let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);\r\n      return this.scheduleSubmit(formEl, ref, opts, push);\r\n    } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\r\n      let [ref, els] = refGenerator();\r\n      let proxyRefGen = () => [ref, els, opts];\r\n      this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {\r\n        let formData = serializeForm(formEl, {});\r\n        this.pushWithReply(proxyRefGen, \"event\", {\r\n          type: \"form\",\r\n          event: phxEvent,\r\n          value: formData,\r\n          cid\r\n        }, onReply);\r\n      });\r\n    } else {\r\n      let formData = serializeForm(formEl, {});\r\n      this.pushWithReply(refGenerator, \"event\", {\r\n        type: \"form\",\r\n        event: phxEvent,\r\n        value: formData,\r\n        cid\r\n      }, onReply);\r\n    }\r\n  }\r\n  uploadFiles(formEl, targetCtx, ref, cid, onComplete) {\r\n    let joinCountAtUpload = this.joinCount;\r\n    let inputEls = LiveUploader.activeFileInputs(formEl);\r\n    let numFileInputsInProgress = inputEls.length;\r\n    inputEls.forEach((inputEl) => {\r\n      let uploader = new LiveUploader(inputEl, this, () => {\r\n        numFileInputsInProgress--;\r\n        if (numFileInputsInProgress === 0) {\r\n          onComplete();\r\n        }\r\n      });\r\n      this.uploaders[inputEl] = uploader;\r\n      let entries = uploader.entries().map((entry) => entry.toPreflightPayload());\r\n      let payload = {\r\n        ref: inputEl.getAttribute(PHX_UPLOAD_REF),\r\n        entries,\r\n        cid: this.targetComponentID(inputEl.form, targetCtx)\r\n      };\r\n      this.log(\"upload\", () => [\"sending preflight request\", payload]);\r\n      this.pushWithReply(null, \"allow_upload\", payload, (resp) => {\r\n        this.log(\"upload\", () => [\"got preflight response\", resp]);\r\n        if (resp.error) {\r\n          this.undoRefs(ref);\r\n          let [entry_ref, reason] = resp.error;\r\n          this.log(\"upload\", () => [`error for entry ${entry_ref}`, reason]);\r\n        } else {\r\n          let onError = (callback) => {\r\n            this.channel.onError(() => {\r\n              if (this.joinCount === joinCountAtUpload) {\r\n                callback();\r\n              }\r\n            });\r\n          };\r\n          uploader.initAdapterUpload(resp, onError, this.liveSocket);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  dispatchUploads(name, filesOrBlobs) {\r\n    let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);\r\n    if (inputs.length === 0) {\r\n      logError(`no live file inputs found matching the name \"${name}\"`);\r\n    } else if (inputs.length > 1) {\r\n      logError(`duplicate live file inputs found matching the name \"${name}\"`);\r\n    } else {\r\n      dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });\r\n    }\r\n  }\r\n  pushFormRecovery(form, newCid, callback) {\r\n    this.liveSocket.withinOwners(form, (view, targetCtx) => {\r\n      let input = form.elements[0];\r\n      let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding(\"change\"));\r\n      js_default.exec(\"change\", phxEvent, view, input, [\"push\", { _target: input.name, newCid, callback }]);\r\n    });\r\n  }\r\n  pushLinkPatch(href, targetEl, callback) {\r\n    let linkRef = this.liveSocket.setPendingLink(href);\r\n    let refGen = targetEl ? () => this.putRef([targetEl], \"click\") : null;\r\n    let fallback = () => this.liveSocket.redirect(window.location.href);\r\n    let push = this.pushWithReply(refGen, \"live_patch\", { url: href }, (resp) => {\r\n      this.liveSocket.requestDOMUpdate(() => {\r\n        if (resp.link_redirect) {\r\n          this.liveSocket.replaceMain(href, null, callback, linkRef);\r\n        } else {\r\n          if (this.liveSocket.commitPendingLink(linkRef)) {\r\n            this.href = href;\r\n          }\r\n          this.applyPendingUpdates();\r\n          callback && callback(linkRef);\r\n        }\r\n      });\r\n    });\r\n    if (push) {\r\n      push.receive(\"timeout\", fallback);\r\n    } else {\r\n      fallback();\r\n    }\r\n  }\r\n  formsForRecovery(html) {\r\n    if (this.joinCount === 0) {\r\n      return [];\r\n    }\r\n    let phxChange = this.binding(\"change\");\r\n    let template = document.createElement(\"template\");\r\n    template.innerHTML = html;\r\n    return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\").map((form) => {\r\n      let newForm = template.content.querySelector(`form[id=\"${form.id}\"][${phxChange}=\"${form.getAttribute(phxChange)}\"]`);\r\n      if (newForm) {\r\n        return [form, newForm, this.targetComponentID(newForm)];\r\n      } else {\r\n        return [form, null, null];\r\n      }\r\n    }).filter(([form, newForm, newCid]) => newForm);\r\n  }\r\n  maybePushComponentsDestroyed(destroyedCIDs) {\r\n    let willDestroyCIDs = destroyedCIDs.filter((cid) => {\r\n      return dom_default.findComponentNodeList(this.el, cid).length === 0;\r\n    });\r\n    if (willDestroyCIDs.length > 0) {\r\n      this.pruningCIDs.push(...willDestroyCIDs);\r\n      this.pushWithReply(null, \"cids_will_destroy\", { cids: willDestroyCIDs }, () => {\r\n        this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);\r\n        let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {\r\n          return dom_default.findComponentNodeList(this.el, cid).length === 0;\r\n        });\r\n        if (completelyDestroyCIDs.length > 0) {\r\n          this.pushWithReply(null, \"cids_destroyed\", { cids: completelyDestroyCIDs }, (resp) => {\r\n            this.rendered.pruneCIDs(resp.cids);\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n  ownsElement(el) {\r\n    let parentViewEl = el.closest(PHX_VIEW_SELECTOR);\r\n    return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;\r\n  }\r\n  submitForm(form, targetCtx, phxEvent, opts = {}) {\r\n    dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);\r\n    let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);\r\n    let inputs = Array.from(form.elements);\r\n    inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));\r\n    this.liveSocket.blurActiveElement(this);\r\n    this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {\r\n      inputs.forEach((input) => dom_default.showError(input, phxFeedback));\r\n      this.liveSocket.restorePreviouslyActiveFocus();\r\n    });\r\n  }\r\n  binding(kind) {\r\n    return this.liveSocket.binding(kind);\r\n  }\r\n};\r\n\r\n// js/phoenix_live_view/live_socket.js\r\nvar LiveSocket = class {\r\n  constructor(url, phxSocket, opts = {}) {\r\n    this.unloaded = false;\r\n    if (!phxSocket || phxSocket.constructor.name === \"Object\") {\r\n      throw new Error(`\r\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\r\n\r\n          import {Socket} from \"phoenix\"\r\n          import {LiveSocket} from \"phoenix_live_view\"\r\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\r\n      `);\r\n    }\r\n    this.socket = new phxSocket(url, opts);\r\n    this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\r\n    this.opts = opts;\r\n    this.params = closure(opts.params || {});\r\n    this.viewLogger = opts.viewLogger;\r\n    this.metadataCallbacks = opts.metadata || {};\r\n    this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\r\n    this.activeElement = null;\r\n    this.prevActive = null;\r\n    this.silenced = false;\r\n    this.main = null;\r\n    this.outgoingMainEl = null;\r\n    this.clickStartedAtTarget = null;\r\n    this.linkRef = 1;\r\n    this.roots = {};\r\n    this.href = window.location.href;\r\n    this.pendingLink = null;\r\n    this.currentLocation = clone(window.location);\r\n    this.hooks = opts.hooks || {};\r\n    this.uploaders = opts.uploaders || {};\r\n    this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\r\n    this.reloadWithJitterTimer = null;\r\n    this.maxReloads = opts.maxReloads || MAX_RELOADS;\r\n    this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;\r\n    this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;\r\n    this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;\r\n    this.localStorage = opts.localStorage || window.localStorage;\r\n    this.sessionStorage = opts.sessionStorage || window.sessionStorage;\r\n    this.boundTopLevelEvents = false;\r\n    this.domCallbacks = Object.assign({ onNodeAdded: closure(), onBeforeElUpdated: closure() }, opts.dom || {});\r\n    this.transitions = new TransitionSet();\r\n    window.addEventListener(\"pagehide\", (_e) => {\r\n      this.unloaded = true;\r\n    });\r\n    this.socket.onOpen(() => {\r\n      if (this.isUnloaded()) {\r\n        window.location.reload();\r\n      }\r\n    });\r\n  }\r\n  isProfileEnabled() {\r\n    return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\r\n  }\r\n  isDebugEnabled() {\r\n    return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\r\n  }\r\n  isDebugDisabled() {\r\n    return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"false\";\r\n  }\r\n  enableDebug() {\r\n    this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\r\n  }\r\n  enableProfiling() {\r\n    this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\r\n  }\r\n  disableDebug() {\r\n    this.sessionStorage.setItem(PHX_LV_DEBUG, \"false\");\r\n  }\r\n  disableProfiling() {\r\n    this.sessionStorage.removeItem(PHX_LV_PROFILE);\r\n  }\r\n  enableLatencySim(upperBoundMs) {\r\n    this.enableDebug();\r\n    console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\");\r\n    this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\r\n  }\r\n  disableLatencySim() {\r\n    this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\r\n  }\r\n  getLatencySim() {\r\n    let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\r\n    return str ? parseInt(str) : null;\r\n  }\r\n  getSocket() {\r\n    return this.socket;\r\n  }\r\n  connect() {\r\n    if (window.location.hostname === \"localhost\" && !this.isDebugDisabled()) {\r\n      this.enableDebug();\r\n    }\r\n    let doConnect = () => {\r\n      if (this.joinRootViews()) {\r\n        this.bindTopLevelEvents();\r\n        this.socket.connect();\r\n      } else if (this.main) {\r\n        this.socket.connect();\r\n      } else {\r\n        this.bindTopLevelEvents({ dead: true });\r\n      }\r\n      this.joinDeadView();\r\n    };\r\n    if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\r\n      doConnect();\r\n    } else {\r\n      document.addEventListener(\"DOMContentLoaded\", () => doConnect());\r\n    }\r\n  }\r\n  disconnect(callback) {\r\n    clearTimeout(this.reloadWithJitterTimer);\r\n    this.socket.disconnect(callback);\r\n  }\r\n  replaceTransport(transport) {\r\n    clearTimeout(this.reloadWithJitterTimer);\r\n    this.socket.replaceTransport(transport);\r\n    this.connect();\r\n  }\r\n  execJS(el, encodedJS, eventType = null) {\r\n    this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));\r\n  }\r\n  unload() {\r\n    if (this.unloaded) {\r\n      return;\r\n    }\r\n    if (this.main && this.isConnected()) {\r\n      this.log(this.main, \"socket\", () => [\"disconnect for page nav\"]);\r\n    }\r\n    this.unloaded = true;\r\n    this.destroyAllViews();\r\n    this.disconnect();\r\n  }\r\n  triggerDOM(kind, args) {\r\n    this.domCallbacks[kind](...args);\r\n  }\r\n  time(name, func) {\r\n    if (!this.isProfileEnabled() || !console.time) {\r\n      return func();\r\n    }\r\n    console.time(name);\r\n    let result = func();\r\n    console.timeEnd(name);\r\n    return result;\r\n  }\r\n  log(view, kind, msgCallback) {\r\n    if (this.viewLogger) {\r\n      let [msg, obj] = msgCallback();\r\n      this.viewLogger(view, kind, msg, obj);\r\n    } else if (this.isDebugEnabled()) {\r\n      let [msg, obj] = msgCallback();\r\n      debug(view, kind, msg, obj);\r\n    }\r\n  }\r\n  requestDOMUpdate(callback) {\r\n    this.transitions.after(callback);\r\n  }\r\n  transition(time, onStart, onDone = function() {\r\n  }) {\r\n    this.transitions.addTransition(time, onStart, onDone);\r\n  }\r\n  onChannel(channel, event, cb) {\r\n    channel.on(event, (data) => {\r\n      let latency = this.getLatencySim();\r\n      if (!latency) {\r\n        cb(data);\r\n      } else {\r\n        setTimeout(() => cb(data), latency);\r\n      }\r\n    });\r\n  }\r\n  wrapPush(view, opts, push) {\r\n    let latency = this.getLatencySim();\r\n    let oldJoinCount = view.joinCount;\r\n    if (!latency) {\r\n      if (this.isConnected() && opts.timeout) {\r\n        return push().receive(\"timeout\", () => {\r\n          if (view.joinCount === oldJoinCount && !view.isDestroyed()) {\r\n            this.reloadWithJitter(view, () => {\r\n              this.log(view, \"timeout\", () => [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"]);\r\n            });\r\n          }\r\n        });\r\n      } else {\r\n        return push();\r\n      }\r\n    }\r\n    let fakePush = {\r\n      receives: [],\r\n      receive(kind, cb) {\r\n        this.receives.push([kind, cb]);\r\n      }\r\n    };\r\n    setTimeout(() => {\r\n      if (view.isDestroyed()) {\r\n        return;\r\n      }\r\n      fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());\r\n    }, latency);\r\n    return fakePush;\r\n  }\r\n  reloadWithJitter(view, log) {\r\n    clearTimeout(this.reloadWithJitterTimer);\r\n    this.disconnect();\r\n    let minMs = this.reloadJitterMin;\r\n    let maxMs = this.reloadJitterMax;\r\n    let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\r\n    let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);\r\n    if (tries > this.maxReloads) {\r\n      afterMs = this.failsafeJitter;\r\n    }\r\n    this.reloadWithJitterTimer = setTimeout(() => {\r\n      if (view.isDestroyed() || view.isConnected()) {\r\n        return;\r\n      }\r\n      view.destroy();\r\n      log ? log() : this.log(view, \"join\", () => [`encountered ${tries} consecutive reloads`]);\r\n      if (tries > this.maxReloads) {\r\n        this.log(view, \"join\", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);\r\n      }\r\n      if (this.hasPendingLink()) {\r\n        window.location = this.pendingLink;\r\n      } else {\r\n        window.location.reload();\r\n      }\r\n    }, afterMs);\r\n  }\r\n  getHookCallbacks(name) {\r\n    return name && name.startsWith(\"Phoenix.\") ? hooks_default[name.split(\".\")[1]] : this.hooks[name];\r\n  }\r\n  isUnloaded() {\r\n    return this.unloaded;\r\n  }\r\n  isConnected() {\r\n    return this.socket.isConnected();\r\n  }\r\n  getBindingPrefix() {\r\n    return this.bindingPrefix;\r\n  }\r\n  binding(kind) {\r\n    return `${this.getBindingPrefix()}${kind}`;\r\n  }\r\n  channel(topic, params) {\r\n    return this.socket.channel(topic, params);\r\n  }\r\n  joinDeadView() {\r\n    let body = document.body;\r\n    if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {\r\n      let view = this.newRootView(body);\r\n      view.setHref(this.getHref());\r\n      view.joinDead();\r\n      if (!this.main) {\r\n        this.main = view;\r\n      }\r\n      window.requestAnimationFrame(() => view.execNewMounted());\r\n    }\r\n  }\r\n  joinRootViews() {\r\n    let rootsFound = false;\r\n    dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {\r\n      if (!this.getRootById(rootEl.id)) {\r\n        let view = this.newRootView(rootEl);\r\n        view.setHref(this.getHref());\r\n        view.join();\r\n        if (rootEl.hasAttribute(PHX_MAIN)) {\r\n          this.main = view;\r\n        }\r\n      }\r\n      rootsFound = true;\r\n    });\r\n    return rootsFound;\r\n  }\r\n  redirect(to, flash) {\r\n    this.disconnect();\r\n    browser_default.redirect(to, flash);\r\n  }\r\n  replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {\r\n    let liveReferer = this.currentLocation.href;\r\n    this.outgoingMainEl = this.outgoingMainEl || this.main.el;\r\n    let newMainEl = dom_default.cloneNode(this.outgoingMainEl, \"\");\r\n    this.main.showLoader(this.loaderTimeout);\r\n    this.main.destroy();\r\n    this.main = this.newRootView(newMainEl, flash, liveReferer);\r\n    this.main.setRedirect(href);\r\n    this.transitionRemoves();\r\n    this.main.join((joinCount, onDone) => {\r\n      if (joinCount === 1 && this.commitPendingLink(linkRef)) {\r\n        this.requestDOMUpdate(() => {\r\n          dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));\r\n          this.outgoingMainEl.replaceWith(newMainEl);\r\n          this.outgoingMainEl = null;\r\n          callback && requestAnimationFrame(callback);\r\n          onDone();\r\n        });\r\n      }\r\n    });\r\n  }\r\n  transitionRemoves(elements) {\r\n    let removeAttr = this.binding(\"remove\");\r\n    elements = elements || dom_default.all(document, `[${removeAttr}]`);\r\n    elements.forEach((el) => {\r\n      if (document.body.contains(el)) {\r\n        this.execJS(el, el.getAttribute(removeAttr), \"remove\");\r\n      }\r\n    });\r\n  }\r\n  isPhxView(el) {\r\n    return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\r\n  }\r\n  newRootView(el, flash, liveReferer) {\r\n    let view = new View(el, this, null, flash, liveReferer);\r\n    this.roots[view.id] = view;\r\n    return view;\r\n  }\r\n  owner(childEl, callback) {\r\n    let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;\r\n    if (view) {\r\n      callback(view);\r\n    }\r\n  }\r\n  withinOwners(childEl, callback) {\r\n    this.owner(childEl, (view) => callback(view, childEl));\r\n  }\r\n  getViewByEl(el) {\r\n    let rootId = el.getAttribute(PHX_ROOT_ID);\r\n    return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));\r\n  }\r\n  getRootById(id) {\r\n    return this.roots[id];\r\n  }\r\n  destroyAllViews() {\r\n    for (let id in this.roots) {\r\n      this.roots[id].destroy();\r\n      delete this.roots[id];\r\n    }\r\n    this.main = null;\r\n  }\r\n  destroyViewByEl(el) {\r\n    let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\r\n    if (root && root.id === el.id) {\r\n      root.destroy();\r\n      delete this.roots[root.id];\r\n    } else if (root) {\r\n      root.destroyDescendent(el.id);\r\n    }\r\n  }\r\n  setActiveElement(target) {\r\n    if (this.activeElement === target) {\r\n      return;\r\n    }\r\n    this.activeElement = target;\r\n    let cancel = () => {\r\n      if (target === this.activeElement) {\r\n        this.activeElement = null;\r\n      }\r\n      target.removeEventListener(\"mouseup\", this);\r\n      target.removeEventListener(\"touchend\", this);\r\n    };\r\n    target.addEventListener(\"mouseup\", cancel);\r\n    target.addEventListener(\"touchend\", cancel);\r\n  }\r\n  getActiveElement() {\r\n    if (document.activeElement === document.body) {\r\n      return this.activeElement || document.activeElement;\r\n    } else {\r\n      return document.activeElement || document.body;\r\n    }\r\n  }\r\n  dropActiveElement(view) {\r\n    if (this.prevActive && view.ownsElement(this.prevActive)) {\r\n      this.prevActive = null;\r\n    }\r\n  }\r\n  restorePreviouslyActiveFocus() {\r\n    if (this.prevActive && this.prevActive !== document.body) {\r\n      this.prevActive.focus();\r\n    }\r\n  }\r\n  blurActiveElement() {\r\n    this.prevActive = this.getActiveElement();\r\n    if (this.prevActive !== document.body) {\r\n      this.prevActive.blur();\r\n    }\r\n  }\r\n  bindTopLevelEvents({ dead } = {}) {\r\n    if (this.boundTopLevelEvents) {\r\n      return;\r\n    }\r\n    this.boundTopLevelEvents = true;\r\n    this.socket.onClose((event) => {\r\n      if (event && event.code === 1001) {\r\n        return this.unload();\r\n      }\r\n      if (event && event.code === 1e3 && this.main) {\r\n        return this.reloadWithJitter(this.main);\r\n      }\r\n    });\r\n    document.body.addEventListener(\"click\", function() {\r\n    });\r\n    window.addEventListener(\"pageshow\", (e) => {\r\n      if (e.persisted) {\r\n        this.getSocket().disconnect();\r\n        this.withPageLoading({ to: window.location.href, kind: \"redirect\" });\r\n        window.location.reload();\r\n      }\r\n    }, true);\r\n    if (!dead) {\r\n      this.bindNav();\r\n    }\r\n    this.bindClicks();\r\n    if (!dead) {\r\n      this.bindForms();\r\n    }\r\n    this.bind({ keyup: \"keyup\", keydown: \"keydown\" }, (e, type, view, targetEl, phxEvent, eventTarget) => {\r\n      let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));\r\n      let pressedKey = e.key && e.key.toLowerCase();\r\n      if (matchKey && matchKey.toLowerCase() !== pressedKey) {\r\n        return;\r\n      }\r\n      let data = { key: e.key, ...this.eventMeta(type, e, targetEl) };\r\n      js_default.exec(type, phxEvent, view, targetEl, [\"push\", { data }]);\r\n    });\r\n    this.bind({ blur: \"focusout\", focus: \"focusin\" }, (e, type, view, targetEl, phxEvent, eventTarget) => {\r\n      if (!eventTarget) {\r\n        let data = { key: e.key, ...this.eventMeta(type, e, targetEl) };\r\n        js_default.exec(type, phxEvent, view, targetEl, [\"push\", { data }]);\r\n      }\r\n    });\r\n    this.bind({ blur: \"blur\", focus: \"focus\" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\r\n      if (phxTarget === \"window\") {\r\n        let data = this.eventMeta(type, e, targetEl);\r\n        js_default.exec(type, phxEvent, view, targetEl, [\"push\", { data }]);\r\n      }\r\n    });\r\n    window.addEventListener(\"dragover\", (e) => e.preventDefault());\r\n    window.addEventListener(\"drop\", (e) => {\r\n      e.preventDefault();\r\n      let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {\r\n        return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\r\n      });\r\n      let dropTarget = dropTargetId && document.getElementById(dropTargetId);\r\n      let files = Array.from(e.dataTransfer.files || []);\r\n      if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {\r\n        return;\r\n      }\r\n      LiveUploader.trackFiles(dropTarget, files);\r\n      dropTarget.dispatchEvent(new Event(\"input\", { bubbles: true }));\r\n    });\r\n    this.on(PHX_TRACK_UPLOADS, (e) => {\r\n      let uploadTarget = e.target;\r\n      if (!dom_default.isUploadInput(uploadTarget)) {\r\n        return;\r\n      }\r\n      let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);\r\n      LiveUploader.trackFiles(uploadTarget, files);\r\n      uploadTarget.dispatchEvent(new Event(\"input\", { bubbles: true }));\r\n    });\r\n  }\r\n  eventMeta(eventName, e, targetEl) {\r\n    let callback = this.metadataCallbacks[eventName];\r\n    return callback ? callback(e, targetEl) : {};\r\n  }\r\n  setPendingLink(href) {\r\n    this.linkRef++;\r\n    this.pendingLink = href;\r\n    return this.linkRef;\r\n  }\r\n  commitPendingLink(linkRef) {\r\n    if (this.linkRef !== linkRef) {\r\n      return false;\r\n    } else {\r\n      this.href = this.pendingLink;\r\n      this.pendingLink = null;\r\n      return true;\r\n    }\r\n  }\r\n  getHref() {\r\n    return this.href;\r\n  }\r\n  hasPendingLink() {\r\n    return !!this.pendingLink;\r\n  }\r\n  bind(events, callback) {\r\n    for (let event in events) {\r\n      let browserEventName = events[event];\r\n      this.on(browserEventName, (e) => {\r\n        let binding = this.binding(event);\r\n        let windowBinding = this.binding(`window-${event}`);\r\n        let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\r\n        if (targetPhxEvent) {\r\n          this.debounce(e.target, e, browserEventName, () => {\r\n            this.withinOwners(e.target, (view) => {\r\n              callback(e, event, view, e.target, targetPhxEvent, null);\r\n            });\r\n          });\r\n        } else {\r\n          dom_default.all(document, `[${windowBinding}]`, (el) => {\r\n            let phxEvent = el.getAttribute(windowBinding);\r\n            this.debounce(el, e, browserEventName, () => {\r\n              this.withinOwners(el, (view) => {\r\n                callback(e, event, view, el, phxEvent, \"window\");\r\n              });\r\n            });\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n  bindClicks() {\r\n    window.addEventListener(\"click\", (e) => this.clickStartedAtTarget = e.target);\r\n    this.bindClick(\"click\", \"click\", false);\r\n    this.bindClick(\"mousedown\", \"capture-click\", true);\r\n  }\r\n  bindClick(eventName, bindingName, capture) {\r\n    let click = this.binding(bindingName);\r\n    window.addEventListener(eventName, (e) => {\r\n      let target = null;\r\n      if (capture) {\r\n        target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);\r\n      } else {\r\n        let clickStartedAtTarget = this.clickStartedAtTarget || e.target;\r\n        target = closestPhxBinding(clickStartedAtTarget, click);\r\n        this.dispatchClickAway(e, clickStartedAtTarget);\r\n        this.clickStartedAtTarget = null;\r\n      }\r\n      let phxEvent = target && target.getAttribute(click);\r\n      if (!phxEvent) {\r\n        if (!capture && e.target.href !== void 0 && !dom_default.isExternalClick(e)) {\r\n          this.unload();\r\n        }\r\n        return;\r\n      }\r\n      if (target.getAttribute(\"href\") === \"#\") {\r\n        e.preventDefault();\r\n      }\r\n      this.debounce(target, e, \"click\", () => {\r\n        this.withinOwners(target, (view) => {\r\n          js_default.exec(\"click\", phxEvent, view, target, [\"push\", { data: this.eventMeta(\"click\", e, target) }]);\r\n        });\r\n      });\r\n    }, capture);\r\n  }\r\n  dispatchClickAway(e, clickStartedAt) {\r\n    let phxClickAway = this.binding(\"click-away\");\r\n    dom_default.all(document, `[${phxClickAway}]`, (el) => {\r\n      if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {\r\n        this.withinOwners(e.target, (view) => {\r\n          let phxEvent = el.getAttribute(phxClickAway);\r\n          if (js_default.isVisible(el)) {\r\n            js_default.exec(\"click\", phxEvent, view, el, [\"push\", { data: this.eventMeta(\"click\", e, e.target) }]);\r\n          }\r\n        });\r\n      }\r\n    });\r\n  }\r\n  bindNav() {\r\n    if (!browser_default.canPushState()) {\r\n      return;\r\n    }\r\n    if (history.scrollRestoration) {\r\n      history.scrollRestoration = \"manual\";\r\n    }\r\n    let scrollTimer = null;\r\n    window.addEventListener(\"scroll\", (_e) => {\r\n      clearTimeout(scrollTimer);\r\n      scrollTimer = setTimeout(() => {\r\n        browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));\r\n      }, 100);\r\n    });\r\n    window.addEventListener(\"popstate\", (event) => {\r\n      if (!this.registerNewLocation(window.location)) {\r\n        return;\r\n      }\r\n      let { type, id, root, scroll } = event.state || {};\r\n      let href = window.location.href;\r\n      this.requestDOMUpdate(() => {\r\n        if (this.main.isConnected() && (type === \"patch\" && id === this.main.id)) {\r\n          this.main.pushLinkPatch(href, null);\r\n        } else {\r\n          this.replaceMain(href, null, () => {\r\n            if (root) {\r\n              this.replaceRootHistory();\r\n            }\r\n            if (typeof scroll === \"number\") {\r\n              setTimeout(() => {\r\n                window.scrollTo(0, scroll);\r\n              }, 0);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }, false);\r\n    window.addEventListener(\"click\", (e) => {\r\n      let target = closestPhxBinding(e.target, PHX_LIVE_LINK);\r\n      let type = target && target.getAttribute(PHX_LIVE_LINK);\r\n      let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;\r\n      if (!type || !this.isConnected() || !this.main || wantsNewTab) {\r\n        return;\r\n      }\r\n      let href = target.href;\r\n      let linkState = target.getAttribute(PHX_LINK_STATE);\r\n      e.preventDefault();\r\n      e.stopImmediatePropagation();\r\n      if (this.pendingLink === href) {\r\n        return;\r\n      }\r\n      this.requestDOMUpdate(() => {\r\n        if (type === \"patch\") {\r\n          this.pushHistoryPatch(href, linkState, target);\r\n        } else if (type === \"redirect\") {\r\n          this.historyRedirect(href, linkState);\r\n        } else {\r\n          throw new Error(`expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`);\r\n        }\r\n        let phxClick = target.getAttribute(this.binding(\"click\"));\r\n        if (phxClick) {\r\n          this.requestDOMUpdate(() => this.execJS(target, phxClick, \"click\"));\r\n        }\r\n      });\r\n    }, false);\r\n  }\r\n  dispatchEvent(event, payload = {}) {\r\n    dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });\r\n  }\r\n  dispatchEvents(events) {\r\n    events.forEach(([event, payload]) => this.dispatchEvent(event, payload));\r\n  }\r\n  withPageLoading(info, callback) {\r\n    dom_default.dispatchEvent(window, \"phx:page-loading-start\", { detail: info });\r\n    let done = () => dom_default.dispatchEvent(window, \"phx:page-loading-stop\", { detail: info });\r\n    return callback ? callback(done) : done;\r\n  }\r\n  pushHistoryPatch(href, linkState, targetEl) {\r\n    if (!this.isConnected()) {\r\n      return browser_default.redirect(href);\r\n    }\r\n    this.withPageLoading({ to: href, kind: \"patch\" }, (done) => {\r\n      this.main.pushLinkPatch(href, targetEl, (linkRef) => {\r\n        this.historyPatch(href, linkState, linkRef);\r\n        done();\r\n      });\r\n    });\r\n  }\r\n  historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\r\n    if (!this.commitPendingLink(linkRef)) {\r\n      return;\r\n    }\r\n    browser_default.pushState(linkState, { type: \"patch\", id: this.main.id }, href);\r\n    this.registerNewLocation(window.location);\r\n  }\r\n  historyRedirect(href, linkState, flash) {\r\n    if (!this.isConnected()) {\r\n      return browser_default.redirect(href, flash);\r\n    }\r\n    if (/^\\/$|^\\/[^\\/]+.*$/.test(href)) {\r\n      let { protocol, host } = window.location;\r\n      href = `${protocol}//${host}${href}`;\r\n    }\r\n    let scroll = window.scrollY;\r\n    this.withPageLoading({ to: href, kind: \"redirect\" }, (done) => {\r\n      this.replaceMain(href, flash, () => {\r\n        browser_default.pushState(linkState, { type: \"redirect\", id: this.main.id, scroll }, href);\r\n        this.registerNewLocation(window.location);\r\n        done();\r\n      });\r\n    });\r\n  }\r\n  replaceRootHistory() {\r\n    browser_default.pushState(\"replace\", { root: true, type: \"patch\", id: this.main.id });\r\n  }\r\n  registerNewLocation(newLocation) {\r\n    let { pathname, search } = this.currentLocation;\r\n    if (pathname + search === newLocation.pathname + newLocation.search) {\r\n      return false;\r\n    } else {\r\n      this.currentLocation = clone(newLocation);\r\n      return true;\r\n    }\r\n  }\r\n  bindForms() {\r\n    let iterations = 0;\r\n    let externalFormSubmitted = false;\r\n    this.on(\"submit\", (e) => {\r\n      let phxSubmit = e.target.getAttribute(this.binding(\"submit\"));\r\n      let phxChange = e.target.getAttribute(this.binding(\"change\"));\r\n      if (!externalFormSubmitted && phxChange && !phxSubmit) {\r\n        externalFormSubmitted = true;\r\n        e.preventDefault();\r\n        this.unload();\r\n        this.withinOwners(e.target, (view) => {\r\n          view.disableForm(e.target);\r\n          window.requestAnimationFrame(() => e.target.submit());\r\n        });\r\n      }\r\n    }, true);\r\n    this.on(\"submit\", (e) => {\r\n      let phxEvent = e.target.getAttribute(this.binding(\"submit\"));\r\n      if (!phxEvent) {\r\n        return this.unload();\r\n      }\r\n      e.preventDefault();\r\n      e.target.disabled = true;\r\n      this.withinOwners(e.target, (view) => {\r\n        js_default.exec(\"submit\", phxEvent, view, e.target, [\"push\", {}]);\r\n      });\r\n    }, false);\r\n    for (let type of [\"change\", \"input\"]) {\r\n      this.on(type, (e) => {\r\n        let phxChange = this.binding(\"change\");\r\n        let input = e.target;\r\n        let inputEvent = input.getAttribute(phxChange);\r\n        let formEvent = input.form && input.form.getAttribute(phxChange);\r\n        let phxEvent = inputEvent || formEvent;\r\n        if (!phxEvent) {\r\n          return;\r\n        }\r\n        if (input.type === \"number\" && input.validity && input.validity.badInput) {\r\n          return;\r\n        }\r\n        let dispatcher = inputEvent ? input : input.form;\r\n        let currentIterations = iterations;\r\n        iterations++;\r\n        let { at, type: lastType } = dom_default.private(input, \"prev-iteration\") || {};\r\n        if (at === currentIterations - 1 && type !== lastType) {\r\n          return;\r\n        }\r\n        dom_default.putPrivate(input, \"prev-iteration\", { at: currentIterations, type });\r\n        this.debounce(input, e, type, () => {\r\n          this.withinOwners(dispatcher, (view) => {\r\n            dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);\r\n            if (!dom_default.isTextualInput(input)) {\r\n              this.setActiveElement(input);\r\n            }\r\n            js_default.exec(\"change\", phxEvent, view, input, [\"push\", { _target: e.target.name, dispatcher }]);\r\n          });\r\n        });\r\n      }, false);\r\n    }\r\n  }\r\n  debounce(el, event, eventType, callback) {\r\n    if (eventType === \"blur\" || eventType === \"focusout\") {\r\n      return callback();\r\n    }\r\n    let phxDebounce = this.binding(PHX_DEBOUNCE);\r\n    let phxThrottle = this.binding(PHX_THROTTLE);\r\n    let defaultDebounce = this.defaults.debounce.toString();\r\n    let defaultThrottle = this.defaults.throttle.toString();\r\n    this.withinOwners(el, (view) => {\r\n      let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);\r\n      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {\r\n        callback();\r\n      });\r\n    });\r\n  }\r\n  silenceEvents(callback) {\r\n    this.silenced = true;\r\n    callback();\r\n    this.silenced = false;\r\n  }\r\n  on(event, callback) {\r\n    window.addEventListener(event, (e) => {\r\n      if (!this.silenced) {\r\n        callback(e);\r\n      }\r\n    });\r\n  }\r\n};\r\nvar TransitionSet = class {\r\n  constructor() {\r\n    this.transitions = new Set();\r\n    this.pendingOps = [];\r\n    this.reset();\r\n  }\r\n  reset() {\r\n    this.transitions.forEach((timer) => {\r\n      clearTimeout(timer);\r\n      this.transitions.delete(timer);\r\n    });\r\n    this.flushPendingOps();\r\n  }\r\n  after(callback) {\r\n    if (this.size() === 0) {\r\n      callback();\r\n    } else {\r\n      this.pushPendingOp(callback);\r\n    }\r\n  }\r\n  addTransition(time, onStart, onDone) {\r\n    onStart();\r\n    let timer = setTimeout(() => {\r\n      this.transitions.delete(timer);\r\n      onDone();\r\n      if (this.size() === 0) {\r\n        this.flushPendingOps();\r\n      }\r\n    }, time);\r\n    this.transitions.add(timer);\r\n  }\r\n  pushPendingOp(op) {\r\n    this.pendingOps.push(op);\r\n  }\r\n  size() {\r\n    return this.transitions.size;\r\n  }\r\n  flushPendingOps() {\r\n    this.pendingOps.forEach((op) => op());\r\n    this.pendingOps = [];\r\n  }\r\n};\r\nexport {\r\n  LiveSocket\r\n};\r\n//# sourceMappingURL=phoenix_live_view.esm.js.map\r\n"],"sourceRoot":""}